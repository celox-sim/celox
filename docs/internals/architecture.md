# シミュレータ アーキテクチャ

`veryl-simulator` は、Veryl RTL から JIT コンパイルされたネイティブコードを生成し、サイクルベースのシミュレーションを実行するエンジンです。

## 設計思想とターゲット

本シミュレータは、**「最新の同期回路設計（RTL）の検証効率を最大化すること」**を目的として設計されています。

-   **RTL 特化**: ゲートレベルの遅延（# 遅延）や詳細なデルタサイクルの挙動など、シミュレーション速度とのトレードオフになる物理的タイミングの再現は、設計対象を RTL レベルの論理検証に絞ることで意図的に簡略化されています。
-   **パフォーマンス優先**: インタプリタ的なエミュレーションではなく、SIR (Simulator IR) から JIT コンパイルすることで、ネイティブコードに近い実行スループットを実現します。
-   **設計目標としての整合性**: マルチクロックやゼロ遅延のクロック木など、実際の RTL 設計で遭遇する課題に対して、一貫性を保証するための「マルチフェーズ評価」や「カスケードクロック検出」といった仕組みが設計・実装されています。ただし、現時点では特定の条件下で[競合状態（レースコンディション）が発生する制限](./cascade-limitations.md)があります。

## コンパイルパイプライン

Veryl ソースコードから実行までの変換は、以下の 3 つの主要なフェーズで構成されます。

1.  **Frontend (Parser/Analyzer)**:
    -   Veryl ソースを解析し、アナライザー IR を生成します。
    -   `parser::parse_ir` がこれを入力とし、各モジュールを `SimModule` （SLT（論理式）および SIR（命令列）を含む構造体）に変換します。

2.  **Middle-end (Flattening/Scheduling)**:
    -   **Flattening**: インスタンス階層を平坦化し、モジュールローカルな `VarId` をグローバルな `AbsoluteAddr` へ変換します。ポート接続は `LogicPath` に変換されます。
    -   **Atomization**: 依存関係をビット精度で解析するため、`LogicPath` をビット境界（atom）で分割します。
    -   **Scheduling**: 分割された atom をトポロジカルソートし、組合せ回路の実行順序を決定します。

3.  **Backend (JIT Compilation)**:
    -   **Memory Layout**: 全変数のメモリオフセットを決定し、単一のメモリバッファ上に配置します。
    -   **JIT Engine**: [Cranelift](https://cranelift.dev/) を使用して SIR をネイティブ機械語にコンパイルします。
    -   **Runtime**: コンパイルされた関数ポインタを `EventRef` として管理し、シミュレーションを実行します。

## メモリモデル

シミュレータは、**単一メモリバッファ上の 2 領域モデル**を採用しています。

-   **Stable 領域**: 現在の確定値を保持します。組合せ回路の入力および出力はここを参照します。
-   **Working 領域**: FF の次状態を一時的に保持します。
-   **SignalRef**: `HashMap` を介さない直接的なメモリアクセスを可能にする、オフセットとメタデータをキャッシュしたハンドルです。

## 実行制御ロジック

`Simulation::step` は、以下のフローでシミュレーション時間を 1 歩進めます。

1.  **イベントの抽出**: スケジューラから現在の時刻で発生するイベント（クロック変化など）をすべて取り出します。
2.  **クロックエッジの検出**:
    -   前回の値を `BitSet` で保持しており、今回の更新値と比較することで `posedge` / `negedge` を判定します。
    -   `DomainKind` に基づき、ターゲットとなる FF 群がトリガーされたかを確認します。
3.  **サイレントエッジのスキップ**: 信号値は変更されたが FF のトリガー条件を満たさない（例：立ち上がり指定での立ち下がり）場合、不必要な FF 評価をスキップします。
4.  **マルチフェーズ評価**:
    -   複数のドメインが同時にトリガーされた場合、イベント駆動モデルとしての一貫性を保つため、まず全ドメインで `eval_only` による次状態計算を行います。その後、全計算の完了を待って `apply` により値を Stable 領域に一斉に書き込みます。これにより、同時発生したイベント間での値の不整合を回避します。
5.  **カスケードクロック検出**:
    -   FF の出力が別の FF のクロックになっている（ゼロ遅延クロックツリー）場合を考慮し、ドメイン評価後にクロック信号の変化を再スキャンし、安定するまで評価を繰り返します。

## 関連コンポーネント

-   **`JitBackend`**: コンパイル済み関数ポインタ (`SimFunc`) を保持し、`EventRef` を通じて直接呼び出します。
-   **`Scheduler`**: `BinaryHeap` によるイベント管理を行い、時刻順にイベントをディスパッチします。
-   **`VcdWriter`**: シミュレーション中の信号変化を VCD フォーマットで記録します。
