# カスケードクロックと競合状態の処理 (Cascade & Race Condition)

本ドキュメントでは、`veryl-simulator` におけるカスケードクロック（クロックの連鎖）やそれによって引き起こされるレースコンディションの解決策と実装詳細について解説します。

## 1. カスケードクロックにおける整合性の保証

現在の実装では、同一時刻に複数のクロック（およびトリガー信号）が変化する場合、マルチフェーズ評価（Multi-phase Evaluation）を用いることで、論理的な整合性を保証しています。

### 組合せカスケードにおける整合性
あるクロック `clk` の変化が、組合せ回路（`assign`）を介して別のクロック `gclk` を駆動している場合でも、FFの更新タイミングが適切に制御されます。

```veryl
assign gclk = clk;

always_ff (clk) {
    cnt1 = cnt1 + 1;
}

always_ff (gclk) {
    cnt2 = cnt2 + cnt1; // ここで cnt1 の「更新前の値」を正しく参照する
}
```

-   **挙動**: 
    1.  **Phase 1 (Discovery)**: `clk` と `gclk` のエッジを検出。それぞれの FF ブロックを `eval_only` (計算フェーズ) で実行し、結果を一時的な領域（Working Region）に保持します。このとき `cnt2` の計算には、まだ更新されていない Stable 領域の `cnt1` が使用されます。
    2.  **Phase 2 (Apply)**: 全てのトリガードメインの評価が完了したあと、一斉に結果を Stable 領域に反映（Commit）します。
    3.  **Phase 3 (Stabilize)**: 更新された値に基づいて組合せ回路を再評価します。

これにより、物理的な RTL 挙動と一致する「非ブロッキング代入」的な動作が保証されます。

### 順序カスケード（クロック分周など）
FF の出力が別の FF のトリガーとなっている場合（例：分周器）も、トリガー発見ループによって正しく処理されます。

```veryl
always_ff (clk) {
    clk_div = ~clk_div;
}

always_ff (clk_div) {
    cnt = cnt + 1;
}
```

-   **挙動**: 
    -   `clk` の評価によって `clk_div` が変化すると、メインループ内の「トリガー発見ループ」がこれを検出し、同一ステップ内で `clk_div` ドメインも実行リストに加えます。
    -   マルチフェーズ評価により、`clk_div` の変化が見えても、`cnt` の更新は `clk` による他の信号の更新と同期して行われます。

## 2. 検証済みテスト

これらの挙動は、`tests/cascade_race.rs` において検証されており、全てのテストが **PASSED** となることが確認されています。

-   `test_cascade_race_condition`: 組合せカスケードによる値の先取り防止を検証。
-   `test_sequential_cascade_race_condition`: 順序カスケード（分周クロック）によるトリガー伝播の正確性を検証。

## 3. 実装のポイント

1.  **Working Region (2-Region Memory)**: 計算結果を即座に反映せず、一時的に保持する Working 領域を導入しました。
2.  **Split Blocks (eval_only / apply)**: JIT コンパイラが FF ブロックを「計算」と「更新」の 2 つの実行単位に分割して生成します。
3.  **Trigger Discovery Loop**: シミュレーションステップ内で、信号の変化が新たなトリガーを引き起こさなくなるまで評価と組合せ伝播を繰り返します。

## 4. 現在の制限

-   **循環依存 (Zero-delay Loop)**: クロック間に組合せ回路のループがある場合、シミュレータのビルド時（`Simulator::builder().build()`）に `CombinationalLoop` エラーとして静的に検出・拒否されます。
-   **シングルフェーズ最適化**: あるシミュレーションステップにおいて、発火したトリガーが1つだけかつカスケード対象でない場合、eval_only/apply の分割をスキップし `eval_ff_at` で一括実行する最適化が適用されます。これは設計全体の性質ではなくステップ単位の判定です。
