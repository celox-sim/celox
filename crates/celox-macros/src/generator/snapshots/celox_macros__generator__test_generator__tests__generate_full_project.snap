---
source: crates/celox-macros/src/generator/test_generator.rs
expression: code
---
pub struct Module04 {
    pub a: celox::SignalRef,
    pub clk: celox::EventRef,
    pub rst: celox::SignalRef,
    pub c: celox::SignalRef,
    pub b: celox::SignalRef,
}
impl Module04 {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            a: sim.signal("a"),
            clk: sim.event("clk"),
            rst: sim.signal("rst"),
            c: sim.signal("c"),
            b: sim.signal("b"),
        }
    }
    pub fn set_a(&self, sim: &mut celox::Simulator, val: u64) {
        sim.modify(|io| io.set(self.a, val)).unwrap();
    }
    pub fn get_a(&self, sim: &mut celox::Simulator) -> u64 {
        let val = sim.get(self.a);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "a"))
    }
    pub fn set_a_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.a, val, mask)).unwrap();
    }
    pub fn get_a_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.a)
    }
    pub fn set_rst(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.rst, val)).unwrap();
    }
    pub fn get_rst(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.rst);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "rst"))
    }
    pub fn set_rst_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.rst, val, mask)).unwrap();
    }
    pub fn get_rst_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.rst)
    }
    pub fn set_c(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.c, val)).unwrap();
    }
    pub fn get_c(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.c);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "c"))
    }
    pub fn set_c_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.c, val, mask)).unwrap();
    }
    pub fn get_c_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.c)
    }
    pub fn set_b(&self, sim: &mut celox::Simulator, val: u64) {
        sim.modify(|io| io.set(self.b, val)).unwrap();
    }
    pub fn get_b(&self, sim: &mut celox::Simulator) -> u64 {
        let val = sim.get(self.b);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "b"))
    }
    pub fn set_b_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.b, val, mask)).unwrap();
    }
    pub fn get_b_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.b)
    }
    pub fn bind<'a>(&'a self, sim: &'a mut celox::Simulator) -> Module04Bound<'a> {
        Module04Bound { sim, ids: self }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {
        sim.tick(self.clk).unwrap();
    }
}
pub struct Module04Bound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a Module04,
}
impl<'a> Module04Bound<'a> {
    pub fn set_a(&mut self, val: u64) {
        self.ids.set_a(self.sim, val);
    }
    pub fn get_a(&mut self) -> u64 {
        self.ids.get_a(self.sim)
    }
    pub fn set_a_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_a_4state(self.sim, val, mask);
    }
    pub fn get_a_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_a_4state(self.sim)
    }
    pub fn set_rst(&mut self, val: u8) {
        self.ids.set_rst(self.sim, val);
    }
    pub fn get_rst(&mut self) -> u8 {
        self.ids.get_rst(self.sim)
    }
    pub fn set_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_rst_4state(self.sim, val, mask);
    }
    pub fn get_rst_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_rst_4state(self.sim)
    }
    pub fn set_c(&mut self, val: u8) {
        self.ids.set_c(self.sim, val);
    }
    pub fn get_c(&mut self) -> u8 {
        self.ids.get_c(self.sim)
    }
    pub fn set_c_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_c_4state(self.sim, val, mask);
    }
    pub fn get_c_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_c_4state(self.sim)
    }
    pub fn set_b(&mut self, val: u64) {
        self.ids.set_b(self.sim, val);
    }
    pub fn get_b(&mut self) -> u64 {
        self.ids.get_b(self.sim)
    }
    pub fn set_b_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_b_4state(self.sim, val, mask);
    }
    pub fn get_b_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_b_4state(self.sim)
    }
    pub fn tick(&mut self) {
        self.sim.tick(self.ids.clk).unwrap();
    }
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut Module04IO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = Module04IO { io, ids: self.ids };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct Module04IO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a Module04,
}
impl<'a, 'b> Module04IO<'a, 'b> {
    pub fn set_a(&mut self, val: u64) {
        self.io.set(self.ids.a, val);
    }
    pub fn set_a_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.a, val, mask);
    }
    pub fn set_rst(&mut self, val: u8) {
        self.io.set(self.ids.rst, val);
    }
    pub fn set_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.rst, val, mask);
    }
    pub fn set_c(&mut self, val: u8) {
        self.io.set(self.ids.c, val);
    }
    pub fn set_c_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.c, val, mask);
    }
    pub fn set_b(&mut self, val: u64) {
        self.io.set(self.ids.b, val);
    }
    pub fn set_b_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.b, val, mask);
    }
}
pub struct SorterCell {
    pub i_val: celox::SignalRef,
    pub clk: celox::EventRef,
    pub rst: celox::SignalRef,
    pub o_reg: celox::SignalRef,
    pub o_val: celox::SignalRef,
    pub en: celox::SignalRef,
}
impl SorterCell {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            i_val: sim.signal("i_val"),
            clk: sim.event("clk"),
            rst: sim.signal("rst"),
            o_reg: sim.signal("o_reg"),
            o_val: sim.signal("o_val"),
            en: sim.signal("en"),
        }
    }
    pub fn set_i_val(&self, sim: &mut celox::Simulator, val: u16) {
        sim.modify(|io| io.set(self.i_val, val)).unwrap();
    }
    pub fn get_i_val(&self, sim: &mut celox::Simulator) -> u16 {
        let val = sim.get(self.i_val);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_val"))
    }
    pub fn set_i_val_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_val, val, mask)).unwrap();
    }
    pub fn get_i_val_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_val)
    }
    pub fn set_rst(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.rst, val)).unwrap();
    }
    pub fn get_rst(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.rst);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "rst"))
    }
    pub fn set_rst_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.rst, val, mask)).unwrap();
    }
    pub fn get_rst_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.rst)
    }
    pub fn set_o_reg(&self, sim: &mut celox::Simulator, val: u16) {
        sim.modify(|io| io.set(self.o_reg, val)).unwrap();
    }
    pub fn get_o_reg(&self, sim: &mut celox::Simulator) -> u16 {
        let val = sim.get(self.o_reg);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_reg"))
    }
    pub fn set_o_reg_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_reg, val, mask)).unwrap();
    }
    pub fn get_o_reg_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_reg)
    }
    pub fn set_o_val(&self, sim: &mut celox::Simulator, val: u16) {
        sim.modify(|io| io.set(self.o_val, val)).unwrap();
    }
    pub fn get_o_val(&self, sim: &mut celox::Simulator) -> u16 {
        let val = sim.get(self.o_val);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_val"))
    }
    pub fn set_o_val_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_val, val, mask)).unwrap();
    }
    pub fn get_o_val_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_val)
    }
    pub fn set_en(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.en, val)).unwrap();
    }
    pub fn get_en(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.en);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "en"))
    }
    pub fn set_en_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.en, val, mask)).unwrap();
    }
    pub fn get_en_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.en)
    }
    pub fn bind<'a>(&'a self, sim: &'a mut celox::Simulator) -> SorterCellBound<'a> {
        SorterCellBound { sim, ids: self }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {
        sim.tick(self.clk).unwrap();
    }
}
pub struct SorterCellBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a SorterCell,
}
impl<'a> SorterCellBound<'a> {
    pub fn set_i_val(&mut self, val: u16) {
        self.ids.set_i_val(self.sim, val);
    }
    pub fn get_i_val(&mut self) -> u16 {
        self.ids.get_i_val(self.sim)
    }
    pub fn set_i_val_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_val_4state(self.sim, val, mask);
    }
    pub fn get_i_val_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_val_4state(self.sim)
    }
    pub fn set_rst(&mut self, val: u8) {
        self.ids.set_rst(self.sim, val);
    }
    pub fn get_rst(&mut self) -> u8 {
        self.ids.get_rst(self.sim)
    }
    pub fn set_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_rst_4state(self.sim, val, mask);
    }
    pub fn get_rst_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_rst_4state(self.sim)
    }
    pub fn set_o_reg(&mut self, val: u16) {
        self.ids.set_o_reg(self.sim, val);
    }
    pub fn get_o_reg(&mut self) -> u16 {
        self.ids.get_o_reg(self.sim)
    }
    pub fn set_o_reg_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_reg_4state(self.sim, val, mask);
    }
    pub fn get_o_reg_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_reg_4state(self.sim)
    }
    pub fn set_o_val(&mut self, val: u16) {
        self.ids.set_o_val(self.sim, val);
    }
    pub fn get_o_val(&mut self) -> u16 {
        self.ids.get_o_val(self.sim)
    }
    pub fn set_o_val_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_val_4state(self.sim, val, mask);
    }
    pub fn get_o_val_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_val_4state(self.sim)
    }
    pub fn set_en(&mut self, val: u8) {
        self.ids.set_en(self.sim, val);
    }
    pub fn get_en(&mut self) -> u8 {
        self.ids.get_en(self.sim)
    }
    pub fn set_en_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_en_4state(self.sim, val, mask);
    }
    pub fn get_en_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_en_4state(self.sim)
    }
    pub fn tick(&mut self) {
        self.sim.tick(self.ids.clk).unwrap();
    }
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut SorterCellIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = SorterCellIO { io, ids: self.ids };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct SorterCellIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a SorterCell,
}
impl<'a, 'b> SorterCellIO<'a, 'b> {
    pub fn set_i_val(&mut self, val: u16) {
        self.io.set(self.ids.i_val, val);
    }
    pub fn set_i_val_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_val, val, mask);
    }
    pub fn set_rst(&mut self, val: u8) {
        self.io.set(self.ids.rst, val);
    }
    pub fn set_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.rst, val, mask);
    }
    pub fn set_o_reg(&mut self, val: u16) {
        self.io.set(self.ids.o_reg, val);
    }
    pub fn set_o_reg_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_reg, val, mask);
    }
    pub fn set_o_val(&mut self, val: u16) {
        self.io.set(self.ids.o_val, val);
    }
    pub fn set_o_val_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_val, val, mask);
    }
    pub fn set_en(&mut self, val: u8) {
        self.io.set(self.ids.en, val);
    }
    pub fn set_en_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.en, val, mask);
    }
}
pub struct LinearSorter {
    pub clk: celox::EventRef,
    pub d_out: celox::SignalRef,
    pub rst: celox::SignalRef,
    pub d_in: celox::SignalRef,
    pub en: celox::SignalRef,
}
impl LinearSorter {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            clk: sim.event("clk"),
            d_out: sim.signal("d_out"),
            rst: sim.signal("rst"),
            d_in: sim.signal("d_in"),
            en: sim.signal("en"),
        }
    }
    pub fn set_d_out(&self, sim: &mut celox::Simulator, index: usize, val: u16) {
        let mut val_full = sim.get(self.d_out);
        let element_width = 16usize;
        let bit_offset = index * element_width;
        let mask = ((celox::BigUint::from(1u32) << element_width) - 1u32) << bit_offset;
        val_full = (val_full.clone() ^ (val_full & &mask))
            | (celox::BigUint::from(val) << bit_offset);
        sim.modify(|io| io.set_wide(self.d_out, val_full)).unwrap();
    }
    pub fn get_d_out(&self, sim: &mut celox::Simulator, index: usize) -> u16 {
        let val_full = sim.get(self.d_out);
        let element_width = 16usize;
        let bit_offset = index * element_width;
        let mask = (celox::BigUint::from(1u32) << element_width) - 1u32;
        let element_val = (val_full >> bit_offset) & mask;
        element_val
            .try_into()
            .unwrap_or_else(|_| panic!("Value overflow for {}[{}]", "d_out", index))
    }
    pub fn set_d_out_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.d_out, val, mask)).unwrap();
    }
    pub fn get_d_out_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.d_out)
    }
    pub fn set_rst(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.rst, val)).unwrap();
    }
    pub fn get_rst(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.rst);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "rst"))
    }
    pub fn set_rst_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.rst, val, mask)).unwrap();
    }
    pub fn get_rst_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.rst)
    }
    pub fn set_d_in(&self, sim: &mut celox::Simulator, val: u16) {
        sim.modify(|io| io.set(self.d_in, val)).unwrap();
    }
    pub fn get_d_in(&self, sim: &mut celox::Simulator) -> u16 {
        let val = sim.get(self.d_in);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "d_in"))
    }
    pub fn set_d_in_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.d_in, val, mask)).unwrap();
    }
    pub fn get_d_in_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.d_in)
    }
    pub fn set_en(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.en, val)).unwrap();
    }
    pub fn get_en(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.en);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "en"))
    }
    pub fn set_en_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.en, val, mask)).unwrap();
    }
    pub fn get_en_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.en)
    }
    pub fn bind<'a>(&'a self, sim: &'a mut celox::Simulator) -> LinearSorterBound<'a> {
        LinearSorterBound {
            sim,
            ids: self,
        }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {
        sim.tick(self.clk).unwrap();
    }
}
pub struct LinearSorterBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a LinearSorter,
}
impl<'a> LinearSorterBound<'a> {
    pub fn set_d_out(&mut self, index: usize, val: u16) {
        self.ids.set_d_out(self.sim, index, val);
    }
    pub fn get_d_out(&mut self, index: usize) -> u16 {
        self.ids.get_d_out(self.sim, index)
    }
    pub fn set_d_out_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_d_out_4state(self.sim, val, mask);
    }
    pub fn get_d_out_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_d_out_4state(self.sim)
    }
    pub fn set_rst(&mut self, val: u8) {
        self.ids.set_rst(self.sim, val);
    }
    pub fn get_rst(&mut self) -> u8 {
        self.ids.get_rst(self.sim)
    }
    pub fn set_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_rst_4state(self.sim, val, mask);
    }
    pub fn get_rst_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_rst_4state(self.sim)
    }
    pub fn set_d_in(&mut self, val: u16) {
        self.ids.set_d_in(self.sim, val);
    }
    pub fn get_d_in(&mut self) -> u16 {
        self.ids.get_d_in(self.sim)
    }
    pub fn set_d_in_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_d_in_4state(self.sim, val, mask);
    }
    pub fn get_d_in_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_d_in_4state(self.sim)
    }
    pub fn set_en(&mut self, val: u8) {
        self.ids.set_en(self.sim, val);
    }
    pub fn get_en(&mut self) -> u8 {
        self.ids.get_en(self.sim)
    }
    pub fn set_en_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_en_4state(self.sim, val, mask);
    }
    pub fn get_en_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_en_4state(self.sim)
    }
    pub fn tick(&mut self) {
        self.sim.tick(self.ids.clk).unwrap();
    }
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut LinearSorterIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = LinearSorterIO {
                    io,
                    ids: self.ids,
                };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct LinearSorterIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a LinearSorter,
}
impl<'a, 'b> LinearSorterIO<'a, 'b> {
    pub fn set_d_out(&mut self, _index: usize, _val: u16) {}
    pub fn set_d_out_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.d_out, val, mask);
    }
    pub fn set_rst(&mut self, val: u8) {
        self.io.set(self.ids.rst, val);
    }
    pub fn set_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.rst, val, mask);
    }
    pub fn set_d_in(&mut self, val: u16) {
        self.io.set(self.ids.d_in, val);
    }
    pub fn set_d_in_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.d_in, val, mask);
    }
    pub fn set_en(&mut self, val: u8) {
        self.io.set(self.ids.en, val);
    }
    pub fn set_en_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.en, val, mask);
    }
}
pub struct async_fifo {
    pub id_rst: celox::SignalRef,
    pub os_full: celox::SignalRef,
    pub is_clk: celox::EventRef,
    pub od_data: celox::SignalRef,
    pub is_push: celox::SignalRef,
    pub is_data: celox::SignalRef,
    pub id_pop: celox::SignalRef,
    pub is_rst: celox::SignalRef,
    pub id_clk: celox::EventRef,
    pub od_empty: celox::SignalRef,
    pub os_almost_full: celox::SignalRef,
}
impl async_fifo {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            id_rst: sim.signal("id_rst"),
            os_full: sim.signal("os_full"),
            is_clk: sim.event("is_clk"),
            od_data: sim.signal("od_data"),
            is_push: sim.signal("is_push"),
            is_data: sim.signal("is_data"),
            id_pop: sim.signal("id_pop"),
            is_rst: sim.signal("is_rst"),
            id_clk: sim.event("id_clk"),
            od_empty: sim.signal("od_empty"),
            os_almost_full: sim.signal("os_almost_full"),
        }
    }
    pub fn set_id_rst(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.id_rst, val)).unwrap();
    }
    pub fn get_id_rst(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.id_rst);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "id_rst"))
    }
    pub fn set_id_rst_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.id_rst, val, mask)).unwrap();
    }
    pub fn get_id_rst_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.id_rst)
    }
    pub fn set_os_full(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.os_full, val)).unwrap();
    }
    pub fn get_os_full(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.os_full);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "os_full"))
    }
    pub fn set_os_full_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.os_full, val, mask)).unwrap();
    }
    pub fn get_os_full_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.os_full)
    }
    pub fn set_od_data(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.od_data, val)).unwrap();
    }
    pub fn get_od_data(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.od_data);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "od_data"))
    }
    pub fn set_od_data_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.od_data, val, mask)).unwrap();
    }
    pub fn get_od_data_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.od_data)
    }
    pub fn set_is_push(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.is_push, val)).unwrap();
    }
    pub fn get_is_push(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.is_push);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "is_push"))
    }
    pub fn set_is_push_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.is_push, val, mask)).unwrap();
    }
    pub fn get_is_push_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.is_push)
    }
    pub fn set_is_data(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.is_data, val)).unwrap();
    }
    pub fn get_is_data(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.is_data);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "is_data"))
    }
    pub fn set_is_data_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.is_data, val, mask)).unwrap();
    }
    pub fn get_is_data_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.is_data)
    }
    pub fn set_id_pop(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.id_pop, val)).unwrap();
    }
    pub fn get_id_pop(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.id_pop);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "id_pop"))
    }
    pub fn set_id_pop_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.id_pop, val, mask)).unwrap();
    }
    pub fn get_id_pop_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.id_pop)
    }
    pub fn set_is_rst(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.is_rst, val)).unwrap();
    }
    pub fn get_is_rst(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.is_rst);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "is_rst"))
    }
    pub fn set_is_rst_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.is_rst, val, mask)).unwrap();
    }
    pub fn get_is_rst_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.is_rst)
    }
    pub fn set_od_empty(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.od_empty, val)).unwrap();
    }
    pub fn get_od_empty(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.od_empty);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "od_empty"))
    }
    pub fn set_od_empty_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.od_empty, val, mask)).unwrap();
    }
    pub fn get_od_empty_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.od_empty)
    }
    pub fn set_os_almost_full(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.os_almost_full, val)).unwrap();
    }
    pub fn get_os_almost_full(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.os_almost_full);
        val.try_into()
            .unwrap_or_else(|_| panic!("Value overflow for {}", "os_almost_full"))
    }
    pub fn set_os_almost_full_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.os_almost_full, val, mask)).unwrap();
    }
    pub fn get_os_almost_full_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.os_almost_full)
    }
    pub fn bind<'a>(&'a self, sim: &'a mut celox::Simulator) -> async_fifoBound<'a> {
        async_fifoBound { sim, ids: self }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {
        sim.tick(self.id_clk).unwrap();
    }
}
pub struct async_fifoBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a async_fifo,
}
impl<'a> async_fifoBound<'a> {
    pub fn set_id_rst(&mut self, val: u8) {
        self.ids.set_id_rst(self.sim, val);
    }
    pub fn get_id_rst(&mut self) -> u8 {
        self.ids.get_id_rst(self.sim)
    }
    pub fn set_id_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_id_rst_4state(self.sim, val, mask);
    }
    pub fn get_id_rst_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_id_rst_4state(self.sim)
    }
    pub fn set_os_full(&mut self, val: u8) {
        self.ids.set_os_full(self.sim, val);
    }
    pub fn get_os_full(&mut self) -> u8 {
        self.ids.get_os_full(self.sim)
    }
    pub fn set_os_full_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_os_full_4state(self.sim, val, mask);
    }
    pub fn get_os_full_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_os_full_4state(self.sim)
    }
    pub fn set_od_data(&mut self, val: u8) {
        self.ids.set_od_data(self.sim, val);
    }
    pub fn get_od_data(&mut self) -> u8 {
        self.ids.get_od_data(self.sim)
    }
    pub fn set_od_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_od_data_4state(self.sim, val, mask);
    }
    pub fn get_od_data_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_od_data_4state(self.sim)
    }
    pub fn set_is_push(&mut self, val: u8) {
        self.ids.set_is_push(self.sim, val);
    }
    pub fn get_is_push(&mut self) -> u8 {
        self.ids.get_is_push(self.sim)
    }
    pub fn set_is_push_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_is_push_4state(self.sim, val, mask);
    }
    pub fn get_is_push_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_is_push_4state(self.sim)
    }
    pub fn set_is_data(&mut self, val: u8) {
        self.ids.set_is_data(self.sim, val);
    }
    pub fn get_is_data(&mut self) -> u8 {
        self.ids.get_is_data(self.sim)
    }
    pub fn set_is_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_is_data_4state(self.sim, val, mask);
    }
    pub fn get_is_data_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_is_data_4state(self.sim)
    }
    pub fn set_id_pop(&mut self, val: u8) {
        self.ids.set_id_pop(self.sim, val);
    }
    pub fn get_id_pop(&mut self) -> u8 {
        self.ids.get_id_pop(self.sim)
    }
    pub fn set_id_pop_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_id_pop_4state(self.sim, val, mask);
    }
    pub fn get_id_pop_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_id_pop_4state(self.sim)
    }
    pub fn set_is_rst(&mut self, val: u8) {
        self.ids.set_is_rst(self.sim, val);
    }
    pub fn get_is_rst(&mut self) -> u8 {
        self.ids.get_is_rst(self.sim)
    }
    pub fn set_is_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_is_rst_4state(self.sim, val, mask);
    }
    pub fn get_is_rst_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_is_rst_4state(self.sim)
    }
    pub fn set_od_empty(&mut self, val: u8) {
        self.ids.set_od_empty(self.sim, val);
    }
    pub fn get_od_empty(&mut self) -> u8 {
        self.ids.get_od_empty(self.sim)
    }
    pub fn set_od_empty_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_od_empty_4state(self.sim, val, mask);
    }
    pub fn get_od_empty_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_od_empty_4state(self.sim)
    }
    pub fn set_os_almost_full(&mut self, val: u8) {
        self.ids.set_os_almost_full(self.sim, val);
    }
    pub fn get_os_almost_full(&mut self) -> u8 {
        self.ids.get_os_almost_full(self.sim)
    }
    pub fn set_os_almost_full_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.ids.set_os_almost_full_4state(self.sim, val, mask);
    }
    pub fn get_os_almost_full_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_os_almost_full_4state(self.sim)
    }
    pub fn tick(&mut self) {
        self.sim.tick(self.ids.id_clk).unwrap();
    }
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut async_fifoIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = async_fifoIO { io, ids: self.ids };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct async_fifoIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a async_fifo,
}
impl<'a, 'b> async_fifoIO<'a, 'b> {
    pub fn set_id_rst(&mut self, val: u8) {
        self.io.set(self.ids.id_rst, val);
    }
    pub fn set_id_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.id_rst, val, mask);
    }
    pub fn set_os_full(&mut self, val: u8) {
        self.io.set(self.ids.os_full, val);
    }
    pub fn set_os_full_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.os_full, val, mask);
    }
    pub fn set_od_data(&mut self, val: u8) {
        self.io.set(self.ids.od_data, val);
    }
    pub fn set_od_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.od_data, val, mask);
    }
    pub fn set_is_push(&mut self, val: u8) {
        self.io.set(self.ids.is_push, val);
    }
    pub fn set_is_push_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.is_push, val, mask);
    }
    pub fn set_is_data(&mut self, val: u8) {
        self.io.set(self.ids.is_data, val);
    }
    pub fn set_is_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.is_data, val, mask);
    }
    pub fn set_id_pop(&mut self, val: u8) {
        self.io.set(self.ids.id_pop, val);
    }
    pub fn set_id_pop_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.id_pop, val, mask);
    }
    pub fn set_is_rst(&mut self, val: u8) {
        self.io.set(self.ids.is_rst, val);
    }
    pub fn set_is_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.is_rst, val, mask);
    }
    pub fn set_od_empty(&mut self, val: u8) {
        self.io.set(self.ids.od_empty, val);
    }
    pub fn set_od_empty_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.od_empty, val, mask);
    }
    pub fn set_os_almost_full(&mut self, val: u8) {
        self.io.set(self.ids.os_almost_full, val);
    }
    pub fn set_os_almost_full_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.io.set_four_state(self.ids.os_almost_full, val, mask);
    }
}
pub struct async_fifo_reset_sync {
    pub od_rst: celox::SignalRef,
    pub is_clk: celox::EventRef,
    pub id_rst: celox::SignalRef,
    pub id_clk: celox::EventRef,
    pub is_rst: celox::SignalRef,
    pub os_rst: celox::SignalRef,
}
impl async_fifo_reset_sync {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            od_rst: sim.signal("od_rst"),
            is_clk: sim.event("is_clk"),
            id_rst: sim.signal("id_rst"),
            id_clk: sim.event("id_clk"),
            is_rst: sim.signal("is_rst"),
            os_rst: sim.signal("os_rst"),
        }
    }
    pub fn set_od_rst(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.od_rst, val)).unwrap();
    }
    pub fn get_od_rst(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.od_rst);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "od_rst"))
    }
    pub fn set_od_rst_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.od_rst, val, mask)).unwrap();
    }
    pub fn get_od_rst_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.od_rst)
    }
    pub fn set_id_rst(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.id_rst, val)).unwrap();
    }
    pub fn get_id_rst(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.id_rst);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "id_rst"))
    }
    pub fn set_id_rst_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.id_rst, val, mask)).unwrap();
    }
    pub fn get_id_rst_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.id_rst)
    }
    pub fn set_is_rst(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.is_rst, val)).unwrap();
    }
    pub fn get_is_rst(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.is_rst);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "is_rst"))
    }
    pub fn set_is_rst_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.is_rst, val, mask)).unwrap();
    }
    pub fn get_is_rst_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.is_rst)
    }
    pub fn set_os_rst(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.os_rst, val)).unwrap();
    }
    pub fn get_os_rst(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.os_rst);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "os_rst"))
    }
    pub fn set_os_rst_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.os_rst, val, mask)).unwrap();
    }
    pub fn get_os_rst_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.os_rst)
    }
    pub fn bind<'a>(
        &'a self,
        sim: &'a mut celox::Simulator,
    ) -> async_fifo_reset_syncBound<'a> {
        async_fifo_reset_syncBound {
            sim,
            ids: self,
        }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {
        sim.tick(self.id_clk).unwrap();
    }
}
pub struct async_fifo_reset_syncBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a async_fifo_reset_sync,
}
impl<'a> async_fifo_reset_syncBound<'a> {
    pub fn set_od_rst(&mut self, val: u8) {
        self.ids.set_od_rst(self.sim, val);
    }
    pub fn get_od_rst(&mut self) -> u8 {
        self.ids.get_od_rst(self.sim)
    }
    pub fn set_od_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_od_rst_4state(self.sim, val, mask);
    }
    pub fn get_od_rst_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_od_rst_4state(self.sim)
    }
    pub fn set_id_rst(&mut self, val: u8) {
        self.ids.set_id_rst(self.sim, val);
    }
    pub fn get_id_rst(&mut self) -> u8 {
        self.ids.get_id_rst(self.sim)
    }
    pub fn set_id_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_id_rst_4state(self.sim, val, mask);
    }
    pub fn get_id_rst_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_id_rst_4state(self.sim)
    }
    pub fn set_is_rst(&mut self, val: u8) {
        self.ids.set_is_rst(self.sim, val);
    }
    pub fn get_is_rst(&mut self) -> u8 {
        self.ids.get_is_rst(self.sim)
    }
    pub fn set_is_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_is_rst_4state(self.sim, val, mask);
    }
    pub fn get_is_rst_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_is_rst_4state(self.sim)
    }
    pub fn set_os_rst(&mut self, val: u8) {
        self.ids.set_os_rst(self.sim, val);
    }
    pub fn get_os_rst(&mut self) -> u8 {
        self.ids.get_os_rst(self.sim)
    }
    pub fn set_os_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_os_rst_4state(self.sim, val, mask);
    }
    pub fn get_os_rst_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_os_rst_4state(self.sim)
    }
    pub fn tick(&mut self) {
        self.sim.tick(self.ids.id_clk).unwrap();
    }
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut async_fifo_reset_syncIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = async_fifo_reset_syncIO {
                    io,
                    ids: self.ids,
                };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct async_fifo_reset_syncIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a async_fifo_reset_sync,
}
impl<'a, 'b> async_fifo_reset_syncIO<'a, 'b> {
    pub fn set_od_rst(&mut self, val: u8) {
        self.io.set(self.ids.od_rst, val);
    }
    pub fn set_od_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.od_rst, val, mask);
    }
    pub fn set_id_rst(&mut self, val: u8) {
        self.io.set(self.ids.id_rst, val);
    }
    pub fn set_id_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.id_rst, val, mask);
    }
    pub fn set_is_rst(&mut self, val: u8) {
        self.io.set(self.ids.is_rst, val);
    }
    pub fn set_is_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.is_rst, val, mask);
    }
    pub fn set_os_rst(&mut self, val: u8) {
        self.io.set(self.ids.os_rst, val);
    }
    pub fn set_os_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.os_rst, val, mask);
    }
}
pub struct async_handshake {
    pub os_ready: celox::SignalRef,
    pub is_valid: celox::SignalRef,
    pub od_data: celox::SignalRef,
    pub is_clk: celox::EventRef,
    pub is_data: celox::SignalRef,
    pub id_ready: celox::SignalRef,
    pub is_rst: celox::SignalRef,
    pub id_clk: celox::EventRef,
    pub od_valid: celox::SignalRef,
    pub id_rst: celox::SignalRef,
}
impl async_handshake {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            os_ready: sim.signal("os_ready"),
            is_valid: sim.signal("is_valid"),
            od_data: sim.signal("od_data"),
            is_clk: sim.event("is_clk"),
            is_data: sim.signal("is_data"),
            id_ready: sim.signal("id_ready"),
            is_rst: sim.signal("is_rst"),
            id_clk: sim.event("id_clk"),
            od_valid: sim.signal("od_valid"),
            id_rst: sim.signal("id_rst"),
        }
    }
    pub fn set_os_ready(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.os_ready, val)).unwrap();
    }
    pub fn get_os_ready(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.os_ready);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "os_ready"))
    }
    pub fn set_os_ready_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.os_ready, val, mask)).unwrap();
    }
    pub fn get_os_ready_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.os_ready)
    }
    pub fn set_is_valid(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.is_valid, val)).unwrap();
    }
    pub fn get_is_valid(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.is_valid);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "is_valid"))
    }
    pub fn set_is_valid_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.is_valid, val, mask)).unwrap();
    }
    pub fn get_is_valid_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.is_valid)
    }
    pub fn set_od_data(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.od_data, val)).unwrap();
    }
    pub fn get_od_data(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.od_data);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "od_data"))
    }
    pub fn set_od_data_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.od_data, val, mask)).unwrap();
    }
    pub fn get_od_data_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.od_data)
    }
    pub fn set_is_data(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.is_data, val)).unwrap();
    }
    pub fn get_is_data(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.is_data);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "is_data"))
    }
    pub fn set_is_data_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.is_data, val, mask)).unwrap();
    }
    pub fn get_is_data_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.is_data)
    }
    pub fn set_id_ready(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.id_ready, val)).unwrap();
    }
    pub fn get_id_ready(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.id_ready);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "id_ready"))
    }
    pub fn set_id_ready_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.id_ready, val, mask)).unwrap();
    }
    pub fn get_id_ready_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.id_ready)
    }
    pub fn set_is_rst(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.is_rst, val)).unwrap();
    }
    pub fn get_is_rst(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.is_rst);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "is_rst"))
    }
    pub fn set_is_rst_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.is_rst, val, mask)).unwrap();
    }
    pub fn get_is_rst_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.is_rst)
    }
    pub fn set_od_valid(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.od_valid, val)).unwrap();
    }
    pub fn get_od_valid(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.od_valid);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "od_valid"))
    }
    pub fn set_od_valid_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.od_valid, val, mask)).unwrap();
    }
    pub fn get_od_valid_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.od_valid)
    }
    pub fn set_id_rst(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.id_rst, val)).unwrap();
    }
    pub fn get_id_rst(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.id_rst);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "id_rst"))
    }
    pub fn set_id_rst_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.id_rst, val, mask)).unwrap();
    }
    pub fn get_id_rst_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.id_rst)
    }
    pub fn bind<'a>(
        &'a self,
        sim: &'a mut celox::Simulator,
    ) -> async_handshakeBound<'a> {
        async_handshakeBound {
            sim,
            ids: self,
        }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {
        sim.tick(self.id_clk).unwrap();
    }
}
pub struct async_handshakeBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a async_handshake,
}
impl<'a> async_handshakeBound<'a> {
    pub fn set_os_ready(&mut self, val: u8) {
        self.ids.set_os_ready(self.sim, val);
    }
    pub fn get_os_ready(&mut self) -> u8 {
        self.ids.get_os_ready(self.sim)
    }
    pub fn set_os_ready_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_os_ready_4state(self.sim, val, mask);
    }
    pub fn get_os_ready_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_os_ready_4state(self.sim)
    }
    pub fn set_is_valid(&mut self, val: u8) {
        self.ids.set_is_valid(self.sim, val);
    }
    pub fn get_is_valid(&mut self) -> u8 {
        self.ids.get_is_valid(self.sim)
    }
    pub fn set_is_valid_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_is_valid_4state(self.sim, val, mask);
    }
    pub fn get_is_valid_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_is_valid_4state(self.sim)
    }
    pub fn set_od_data(&mut self, val: u8) {
        self.ids.set_od_data(self.sim, val);
    }
    pub fn get_od_data(&mut self) -> u8 {
        self.ids.get_od_data(self.sim)
    }
    pub fn set_od_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_od_data_4state(self.sim, val, mask);
    }
    pub fn get_od_data_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_od_data_4state(self.sim)
    }
    pub fn set_is_data(&mut self, val: u8) {
        self.ids.set_is_data(self.sim, val);
    }
    pub fn get_is_data(&mut self) -> u8 {
        self.ids.get_is_data(self.sim)
    }
    pub fn set_is_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_is_data_4state(self.sim, val, mask);
    }
    pub fn get_is_data_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_is_data_4state(self.sim)
    }
    pub fn set_id_ready(&mut self, val: u8) {
        self.ids.set_id_ready(self.sim, val);
    }
    pub fn get_id_ready(&mut self) -> u8 {
        self.ids.get_id_ready(self.sim)
    }
    pub fn set_id_ready_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_id_ready_4state(self.sim, val, mask);
    }
    pub fn get_id_ready_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_id_ready_4state(self.sim)
    }
    pub fn set_is_rst(&mut self, val: u8) {
        self.ids.set_is_rst(self.sim, val);
    }
    pub fn get_is_rst(&mut self) -> u8 {
        self.ids.get_is_rst(self.sim)
    }
    pub fn set_is_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_is_rst_4state(self.sim, val, mask);
    }
    pub fn get_is_rst_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_is_rst_4state(self.sim)
    }
    pub fn set_od_valid(&mut self, val: u8) {
        self.ids.set_od_valid(self.sim, val);
    }
    pub fn get_od_valid(&mut self) -> u8 {
        self.ids.get_od_valid(self.sim)
    }
    pub fn set_od_valid_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_od_valid_4state(self.sim, val, mask);
    }
    pub fn get_od_valid_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_od_valid_4state(self.sim)
    }
    pub fn set_id_rst(&mut self, val: u8) {
        self.ids.set_id_rst(self.sim, val);
    }
    pub fn get_id_rst(&mut self) -> u8 {
        self.ids.get_id_rst(self.sim)
    }
    pub fn set_id_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_id_rst_4state(self.sim, val, mask);
    }
    pub fn get_id_rst_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_id_rst_4state(self.sim)
    }
    pub fn tick(&mut self) {
        self.sim.tick(self.ids.id_clk).unwrap();
    }
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut async_handshakeIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = async_handshakeIO {
                    io,
                    ids: self.ids,
                };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct async_handshakeIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a async_handshake,
}
impl<'a, 'b> async_handshakeIO<'a, 'b> {
    pub fn set_os_ready(&mut self, val: u8) {
        self.io.set(self.ids.os_ready, val);
    }
    pub fn set_os_ready_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.os_ready, val, mask);
    }
    pub fn set_is_valid(&mut self, val: u8) {
        self.io.set(self.ids.is_valid, val);
    }
    pub fn set_is_valid_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.is_valid, val, mask);
    }
    pub fn set_od_data(&mut self, val: u8) {
        self.io.set(self.ids.od_data, val);
    }
    pub fn set_od_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.od_data, val, mask);
    }
    pub fn set_is_data(&mut self, val: u8) {
        self.io.set(self.ids.is_data, val);
    }
    pub fn set_is_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.is_data, val, mask);
    }
    pub fn set_id_ready(&mut self, val: u8) {
        self.io.set(self.ids.id_ready, val);
    }
    pub fn set_id_ready_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.id_ready, val, mask);
    }
    pub fn set_is_rst(&mut self, val: u8) {
        self.io.set(self.ids.is_rst, val);
    }
    pub fn set_is_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.is_rst, val, mask);
    }
    pub fn set_od_valid(&mut self, val: u8) {
        self.io.set(self.ids.od_valid, val);
    }
    pub fn set_od_valid_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.od_valid, val, mask);
    }
    pub fn set_id_rst(&mut self, val: u8) {
        self.io.set(self.ids.id_rst, val);
    }
    pub fn set_id_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.id_rst, val, mask);
    }
}
pub struct binary_decoder {
    pub o_unary: celox::SignalRef,
    pub i_bin: celox::SignalRef,
    pub i_en: celox::SignalRef,
}
impl binary_decoder {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            o_unary: sim.signal("o_unary"),
            i_bin: sim.signal("i_bin"),
            i_en: sim.signal("i_en"),
        }
    }
    pub fn set_o_unary(&self, sim: &mut celox::Simulator, val: celox::BigUint) {
        sim.modify(|io| io.set_wide(self.o_unary, val)).unwrap();
    }
    pub fn get_o_unary(&self, sim: &mut celox::Simulator) -> celox::BigUint {
        let val = sim.get(self.o_unary);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_unary"))
    }
    pub fn set_o_unary_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_unary, val, mask)).unwrap();
    }
    pub fn get_o_unary_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_unary)
    }
    pub fn set_i_bin(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_bin, val)).unwrap();
    }
    pub fn get_i_bin(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_bin);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_bin"))
    }
    pub fn set_i_bin_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_bin, val, mask)).unwrap();
    }
    pub fn get_i_bin_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_bin)
    }
    pub fn set_i_en(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_en, val)).unwrap();
    }
    pub fn get_i_en(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_en);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_en"))
    }
    pub fn set_i_en_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_en, val, mask)).unwrap();
    }
    pub fn get_i_en_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_en)
    }
    pub fn bind<'a>(&'a self, sim: &'a mut celox::Simulator) -> binary_decoderBound<'a> {
        binary_decoderBound {
            sim,
            ids: self,
        }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {}
}
pub struct binary_decoderBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a binary_decoder,
}
impl<'a> binary_decoderBound<'a> {
    pub fn set_o_unary(&mut self, val: celox::BigUint) {
        self.ids.set_o_unary(self.sim, val);
    }
    pub fn get_o_unary(&mut self) -> celox::BigUint {
        self.ids.get_o_unary(self.sim)
    }
    pub fn set_o_unary_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_unary_4state(self.sim, val, mask);
    }
    pub fn get_o_unary_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_unary_4state(self.sim)
    }
    pub fn set_i_bin(&mut self, val: u8) {
        self.ids.set_i_bin(self.sim, val);
    }
    pub fn get_i_bin(&mut self) -> u8 {
        self.ids.get_i_bin(self.sim)
    }
    pub fn set_i_bin_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_bin_4state(self.sim, val, mask);
    }
    pub fn get_i_bin_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_bin_4state(self.sim)
    }
    pub fn set_i_en(&mut self, val: u8) {
        self.ids.set_i_en(self.sim, val);
    }
    pub fn get_i_en(&mut self) -> u8 {
        self.ids.get_i_en(self.sim)
    }
    pub fn set_i_en_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_en_4state(self.sim, val, mask);
    }
    pub fn get_i_en_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_en_4state(self.sim)
    }
    pub fn tick(&mut self) {}
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut binary_decoderIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = binary_decoderIO {
                    io,
                    ids: self.ids,
                };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct binary_decoderIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a binary_decoder,
}
impl<'a, 'b> binary_decoderIO<'a, 'b> {
    pub fn set_o_unary(&mut self, val: celox::BigUint) {
        self.io.set_wide(self.ids.o_unary, val);
    }
    pub fn set_o_unary_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_unary, val, mask);
    }
    pub fn set_i_bin(&mut self, val: u8) {
        self.io.set(self.ids.i_bin, val);
    }
    pub fn set_i_bin_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_bin, val, mask);
    }
    pub fn set_i_en(&mut self, val: u8) {
        self.io.set(self.ids.i_en, val);
    }
    pub fn set_i_en_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_en, val, mask);
    }
}
pub struct _bin_decoder {
    pub o_unary: celox::SignalRef,
    pub i_bin: celox::SignalRef,
}
impl _bin_decoder {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            o_unary: sim.signal("o_unary"),
            i_bin: sim.signal("i_bin"),
        }
    }
    pub fn set_o_unary(&self, sim: &mut celox::Simulator, val: celox::BigUint) {
        sim.modify(|io| io.set_wide(self.o_unary, val)).unwrap();
    }
    pub fn get_o_unary(&self, sim: &mut celox::Simulator) -> celox::BigUint {
        let val = sim.get(self.o_unary);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_unary"))
    }
    pub fn set_o_unary_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_unary, val, mask)).unwrap();
    }
    pub fn get_o_unary_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_unary)
    }
    pub fn set_i_bin(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_bin, val)).unwrap();
    }
    pub fn get_i_bin(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_bin);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_bin"))
    }
    pub fn set_i_bin_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_bin, val, mask)).unwrap();
    }
    pub fn get_i_bin_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_bin)
    }
    pub fn bind<'a>(&'a self, sim: &'a mut celox::Simulator) -> _bin_decoderBound<'a> {
        _bin_decoderBound {
            sim,
            ids: self,
        }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {}
}
pub struct _bin_decoderBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a _bin_decoder,
}
impl<'a> _bin_decoderBound<'a> {
    pub fn set_o_unary(&mut self, val: celox::BigUint) {
        self.ids.set_o_unary(self.sim, val);
    }
    pub fn get_o_unary(&mut self) -> celox::BigUint {
        self.ids.get_o_unary(self.sim)
    }
    pub fn set_o_unary_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_unary_4state(self.sim, val, mask);
    }
    pub fn get_o_unary_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_unary_4state(self.sim)
    }
    pub fn set_i_bin(&mut self, val: u8) {
        self.ids.set_i_bin(self.sim, val);
    }
    pub fn get_i_bin(&mut self) -> u8 {
        self.ids.get_i_bin(self.sim)
    }
    pub fn set_i_bin_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_bin_4state(self.sim, val, mask);
    }
    pub fn get_i_bin_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_bin_4state(self.sim)
    }
    pub fn tick(&mut self) {}
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut _bin_decoderIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = _bin_decoderIO {
                    io,
                    ids: self.ids,
                };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct _bin_decoderIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a _bin_decoder,
}
impl<'a, 'b> _bin_decoderIO<'a, 'b> {
    pub fn set_o_unary(&mut self, val: celox::BigUint) {
        self.io.set_wide(self.ids.o_unary, val);
    }
    pub fn set_o_unary_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_unary, val, mask);
    }
    pub fn set_i_bin(&mut self, val: u8) {
        self.io.set(self.ids.i_bin, val);
    }
    pub fn set_i_bin_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_bin, val, mask);
    }
}
pub struct binary_encoder {
    pub i_unary: celox::SignalRef,
    pub o_bin: celox::SignalRef,
    pub i_en: celox::SignalRef,
}
impl binary_encoder {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            i_unary: sim.signal("i_unary"),
            o_bin: sim.signal("o_bin"),
            i_en: sim.signal("i_en"),
        }
    }
    pub fn set_i_unary(&self, sim: &mut celox::Simulator, val: celox::BigUint) {
        sim.modify(|io| io.set_wide(self.i_unary, val)).unwrap();
    }
    pub fn get_i_unary(&self, sim: &mut celox::Simulator) -> celox::BigUint {
        let val = sim.get(self.i_unary);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_unary"))
    }
    pub fn set_i_unary_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_unary, val, mask)).unwrap();
    }
    pub fn get_i_unary_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_unary)
    }
    pub fn set_o_bin(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_bin, val)).unwrap();
    }
    pub fn get_o_bin(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_bin);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_bin"))
    }
    pub fn set_o_bin_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_bin, val, mask)).unwrap();
    }
    pub fn get_o_bin_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_bin)
    }
    pub fn set_i_en(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_en, val)).unwrap();
    }
    pub fn get_i_en(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_en);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_en"))
    }
    pub fn set_i_en_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_en, val, mask)).unwrap();
    }
    pub fn get_i_en_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_en)
    }
    pub fn bind<'a>(&'a self, sim: &'a mut celox::Simulator) -> binary_encoderBound<'a> {
        binary_encoderBound {
            sim,
            ids: self,
        }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {}
}
pub struct binary_encoderBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a binary_encoder,
}
impl<'a> binary_encoderBound<'a> {
    pub fn set_i_unary(&mut self, val: celox::BigUint) {
        self.ids.set_i_unary(self.sim, val);
    }
    pub fn get_i_unary(&mut self) -> celox::BigUint {
        self.ids.get_i_unary(self.sim)
    }
    pub fn set_i_unary_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_unary_4state(self.sim, val, mask);
    }
    pub fn get_i_unary_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_unary_4state(self.sim)
    }
    pub fn set_o_bin(&mut self, val: u8) {
        self.ids.set_o_bin(self.sim, val);
    }
    pub fn get_o_bin(&mut self) -> u8 {
        self.ids.get_o_bin(self.sim)
    }
    pub fn set_o_bin_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_bin_4state(self.sim, val, mask);
    }
    pub fn get_o_bin_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_bin_4state(self.sim)
    }
    pub fn set_i_en(&mut self, val: u8) {
        self.ids.set_i_en(self.sim, val);
    }
    pub fn get_i_en(&mut self) -> u8 {
        self.ids.get_i_en(self.sim)
    }
    pub fn set_i_en_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_en_4state(self.sim, val, mask);
    }
    pub fn get_i_en_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_en_4state(self.sim)
    }
    pub fn tick(&mut self) {}
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut binary_encoderIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = binary_encoderIO {
                    io,
                    ids: self.ids,
                };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct binary_encoderIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a binary_encoder,
}
impl<'a, 'b> binary_encoderIO<'a, 'b> {
    pub fn set_i_unary(&mut self, val: celox::BigUint) {
        self.io.set_wide(self.ids.i_unary, val);
    }
    pub fn set_i_unary_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_unary, val, mask);
    }
    pub fn set_o_bin(&mut self, val: u8) {
        self.io.set(self.ids.o_bin, val);
    }
    pub fn set_o_bin_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_bin, val, mask);
    }
    pub fn set_i_en(&mut self, val: u8) {
        self.io.set(self.ids.i_en, val);
    }
    pub fn set_i_en_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_en, val, mask);
    }
}
pub struct _binary_encoder {
    pub o_valid: celox::SignalRef,
    pub i_unary: celox::SignalRef,
    pub o_bin: celox::SignalRef,
}
impl _binary_encoder {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            o_valid: sim.signal("o_valid"),
            i_unary: sim.signal("i_unary"),
            o_bin: sim.signal("o_bin"),
        }
    }
    pub fn set_o_valid(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_valid, val)).unwrap();
    }
    pub fn get_o_valid(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_valid);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_valid"))
    }
    pub fn set_o_valid_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_valid, val, mask)).unwrap();
    }
    pub fn get_o_valid_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_valid)
    }
    pub fn set_i_unary(&self, sim: &mut celox::Simulator, val: celox::BigUint) {
        sim.modify(|io| io.set_wide(self.i_unary, val)).unwrap();
    }
    pub fn get_i_unary(&self, sim: &mut celox::Simulator) -> celox::BigUint {
        let val = sim.get(self.i_unary);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_unary"))
    }
    pub fn set_i_unary_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_unary, val, mask)).unwrap();
    }
    pub fn get_i_unary_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_unary)
    }
    pub fn set_o_bin(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_bin, val)).unwrap();
    }
    pub fn get_o_bin(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_bin);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_bin"))
    }
    pub fn set_o_bin_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_bin, val, mask)).unwrap();
    }
    pub fn get_o_bin_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_bin)
    }
    pub fn bind<'a>(
        &'a self,
        sim: &'a mut celox::Simulator,
    ) -> _binary_encoderBound<'a> {
        _binary_encoderBound {
            sim,
            ids: self,
        }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {}
}
pub struct _binary_encoderBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a _binary_encoder,
}
impl<'a> _binary_encoderBound<'a> {
    pub fn set_o_valid(&mut self, val: u8) {
        self.ids.set_o_valid(self.sim, val);
    }
    pub fn get_o_valid(&mut self) -> u8 {
        self.ids.get_o_valid(self.sim)
    }
    pub fn set_o_valid_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_valid_4state(self.sim, val, mask);
    }
    pub fn get_o_valid_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_valid_4state(self.sim)
    }
    pub fn set_i_unary(&mut self, val: celox::BigUint) {
        self.ids.set_i_unary(self.sim, val);
    }
    pub fn get_i_unary(&mut self) -> celox::BigUint {
        self.ids.get_i_unary(self.sim)
    }
    pub fn set_i_unary_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_unary_4state(self.sim, val, mask);
    }
    pub fn get_i_unary_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_unary_4state(self.sim)
    }
    pub fn set_o_bin(&mut self, val: u8) {
        self.ids.set_o_bin(self.sim, val);
    }
    pub fn get_o_bin(&mut self) -> u8 {
        self.ids.get_o_bin(self.sim)
    }
    pub fn set_o_bin_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_bin_4state(self.sim, val, mask);
    }
    pub fn get_o_bin_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_bin_4state(self.sim)
    }
    pub fn tick(&mut self) {}
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut _binary_encoderIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = _binary_encoderIO {
                    io,
                    ids: self.ids,
                };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct _binary_encoderIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a _binary_encoder,
}
impl<'a, 'b> _binary_encoderIO<'a, 'b> {
    pub fn set_o_valid(&mut self, val: u8) {
        self.io.set(self.ids.o_valid, val);
    }
    pub fn set_o_valid_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_valid, val, mask);
    }
    pub fn set_i_unary(&mut self, val: celox::BigUint) {
        self.io.set_wide(self.ids.i_unary, val);
    }
    pub fn set_i_unary_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_unary, val, mask);
    }
    pub fn set_o_bin(&mut self, val: u8) {
        self.io.set(self.ids.o_bin, val);
    }
    pub fn set_o_bin_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_bin, val, mask);
    }
}
pub struct linear_sec_decoder {
    pub o_word: celox::SignalRef,
    pub o_corrected: celox::SignalRef,
    pub i_codeword: celox::SignalRef,
}
impl linear_sec_decoder {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            o_word: sim.signal("o_word"),
            o_corrected: sim.signal("o_corrected"),
            i_codeword: sim.signal("i_codeword"),
        }
    }
    pub fn set_o_word(&self, sim: &mut celox::Simulator, val: u16) {
        sim.modify(|io| io.set(self.o_word, val)).unwrap();
    }
    pub fn get_o_word(&self, sim: &mut celox::Simulator) -> u16 {
        let val = sim.get(self.o_word);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_word"))
    }
    pub fn set_o_word_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_word, val, mask)).unwrap();
    }
    pub fn get_o_word_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_word)
    }
    pub fn set_o_corrected(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_corrected, val)).unwrap();
    }
    pub fn get_o_corrected(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_corrected);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_corrected"))
    }
    pub fn set_o_corrected_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_corrected, val, mask)).unwrap();
    }
    pub fn get_o_corrected_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_corrected)
    }
    pub fn set_i_codeword(&self, sim: &mut celox::Simulator, val: u16) {
        sim.modify(|io| io.set(self.i_codeword, val)).unwrap();
    }
    pub fn get_i_codeword(&self, sim: &mut celox::Simulator) -> u16 {
        let val = sim.get(self.i_codeword);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_codeword"))
    }
    pub fn set_i_codeword_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_codeword, val, mask)).unwrap();
    }
    pub fn get_i_codeword_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_codeword)
    }
    pub fn bind<'a>(
        &'a self,
        sim: &'a mut celox::Simulator,
    ) -> linear_sec_decoderBound<'a> {
        linear_sec_decoderBound {
            sim,
            ids: self,
        }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {}
}
pub struct linear_sec_decoderBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a linear_sec_decoder,
}
impl<'a> linear_sec_decoderBound<'a> {
    pub fn set_o_word(&mut self, val: u16) {
        self.ids.set_o_word(self.sim, val);
    }
    pub fn get_o_word(&mut self) -> u16 {
        self.ids.get_o_word(self.sim)
    }
    pub fn set_o_word_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_word_4state(self.sim, val, mask);
    }
    pub fn get_o_word_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_word_4state(self.sim)
    }
    pub fn set_o_corrected(&mut self, val: u8) {
        self.ids.set_o_corrected(self.sim, val);
    }
    pub fn get_o_corrected(&mut self) -> u8 {
        self.ids.get_o_corrected(self.sim)
    }
    pub fn set_o_corrected_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_corrected_4state(self.sim, val, mask);
    }
    pub fn get_o_corrected_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_corrected_4state(self.sim)
    }
    pub fn set_i_codeword(&mut self, val: u16) {
        self.ids.set_i_codeword(self.sim, val);
    }
    pub fn get_i_codeword(&mut self) -> u16 {
        self.ids.get_i_codeword(self.sim)
    }
    pub fn set_i_codeword_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_codeword_4state(self.sim, val, mask);
    }
    pub fn get_i_codeword_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_codeword_4state(self.sim)
    }
    pub fn tick(&mut self) {}
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut linear_sec_decoderIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = linear_sec_decoderIO {
                    io,
                    ids: self.ids,
                };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct linear_sec_decoderIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a linear_sec_decoder,
}
impl<'a, 'b> linear_sec_decoderIO<'a, 'b> {
    pub fn set_o_word(&mut self, val: u16) {
        self.io.set(self.ids.o_word, val);
    }
    pub fn set_o_word_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_word, val, mask);
    }
    pub fn set_o_corrected(&mut self, val: u8) {
        self.io.set(self.ids.o_corrected, val);
    }
    pub fn set_o_corrected_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_corrected, val, mask);
    }
    pub fn set_i_codeword(&mut self, val: u16) {
        self.io.set(self.ids.i_codeword, val);
    }
    pub fn set_i_codeword_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_codeword, val, mask);
    }
}
pub struct linear_sec_encoder {
    pub i_word: celox::SignalRef,
    pub o_codeword: celox::SignalRef,
}
impl linear_sec_encoder {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            i_word: sim.signal("i_word"),
            o_codeword: sim.signal("o_codeword"),
        }
    }
    pub fn set_i_word(&self, sim: &mut celox::Simulator, val: u16) {
        sim.modify(|io| io.set(self.i_word, val)).unwrap();
    }
    pub fn get_i_word(&self, sim: &mut celox::Simulator) -> u16 {
        let val = sim.get(self.i_word);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_word"))
    }
    pub fn set_i_word_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_word, val, mask)).unwrap();
    }
    pub fn get_i_word_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_word)
    }
    pub fn set_o_codeword(&self, sim: &mut celox::Simulator, val: u16) {
        sim.modify(|io| io.set(self.o_codeword, val)).unwrap();
    }
    pub fn get_o_codeword(&self, sim: &mut celox::Simulator) -> u16 {
        let val = sim.get(self.o_codeword);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_codeword"))
    }
    pub fn set_o_codeword_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_codeword, val, mask)).unwrap();
    }
    pub fn get_o_codeword_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_codeword)
    }
    pub fn bind<'a>(
        &'a self,
        sim: &'a mut celox::Simulator,
    ) -> linear_sec_encoderBound<'a> {
        linear_sec_encoderBound {
            sim,
            ids: self,
        }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {}
}
pub struct linear_sec_encoderBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a linear_sec_encoder,
}
impl<'a> linear_sec_encoderBound<'a> {
    pub fn set_i_word(&mut self, val: u16) {
        self.ids.set_i_word(self.sim, val);
    }
    pub fn get_i_word(&mut self) -> u16 {
        self.ids.get_i_word(self.sim)
    }
    pub fn set_i_word_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_word_4state(self.sim, val, mask);
    }
    pub fn get_i_word_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_word_4state(self.sim)
    }
    pub fn set_o_codeword(&mut self, val: u16) {
        self.ids.set_o_codeword(self.sim, val);
    }
    pub fn get_o_codeword(&mut self) -> u16 {
        self.ids.get_o_codeword(self.sim)
    }
    pub fn set_o_codeword_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_codeword_4state(self.sim, val, mask);
    }
    pub fn get_o_codeword_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_codeword_4state(self.sim)
    }
    pub fn tick(&mut self) {}
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut linear_sec_encoderIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = linear_sec_encoderIO {
                    io,
                    ids: self.ids,
                };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct linear_sec_encoderIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a linear_sec_encoder,
}
impl<'a, 'b> linear_sec_encoderIO<'a, 'b> {
    pub fn set_i_word(&mut self, val: u16) {
        self.io.set(self.ids.i_word, val);
    }
    pub fn set_i_word_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_word, val, mask);
    }
    pub fn set_o_codeword(&mut self, val: u16) {
        self.io.set(self.ids.o_codeword, val);
    }
    pub fn set_o_codeword_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_codeword, val, mask);
    }
}
pub struct counter {
    pub i_set: celox::SignalRef,
    pub i_rst: celox::SignalRef,
    pub o_wrap_around: celox::SignalRef,
    pub i_clear: celox::SignalRef,
    pub o_count: celox::SignalRef,
    pub i_up: celox::SignalRef,
    pub i_clk: celox::EventRef,
    pub i_down: celox::SignalRef,
    pub o_count_next: celox::SignalRef,
    pub i_set_value: celox::SignalRef,
}
impl counter {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            i_set: sim.signal("i_set"),
            i_rst: sim.signal("i_rst"),
            o_wrap_around: sim.signal("o_wrap_around"),
            i_clear: sim.signal("i_clear"),
            o_count: sim.signal("o_count"),
            i_up: sim.signal("i_up"),
            i_clk: sim.event("i_clk"),
            i_down: sim.signal("i_down"),
            o_count_next: sim.signal("o_count_next"),
            i_set_value: sim.signal("i_set_value"),
        }
    }
    pub fn set_i_set(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_set, val)).unwrap();
    }
    pub fn get_i_set(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_set);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_set"))
    }
    pub fn set_i_set_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_set, val, mask)).unwrap();
    }
    pub fn get_i_set_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_set)
    }
    pub fn set_i_rst(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_rst, val)).unwrap();
    }
    pub fn get_i_rst(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_rst);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_rst"))
    }
    pub fn set_i_rst_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_rst, val, mask)).unwrap();
    }
    pub fn get_i_rst_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_rst)
    }
    pub fn set_o_wrap_around(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_wrap_around, val)).unwrap();
    }
    pub fn get_o_wrap_around(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_wrap_around);
        val.try_into()
            .unwrap_or_else(|_| panic!("Value overflow for {}", "o_wrap_around"))
    }
    pub fn set_o_wrap_around_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_wrap_around, val, mask)).unwrap();
    }
    pub fn get_o_wrap_around_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_wrap_around)
    }
    pub fn set_i_clear(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_clear, val)).unwrap();
    }
    pub fn get_i_clear(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_clear);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_clear"))
    }
    pub fn set_i_clear_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_clear, val, mask)).unwrap();
    }
    pub fn get_i_clear_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_clear)
    }
    pub fn set_o_count(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_count, val)).unwrap();
    }
    pub fn get_o_count(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_count);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_count"))
    }
    pub fn set_o_count_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_count, val, mask)).unwrap();
    }
    pub fn get_o_count_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_count)
    }
    pub fn set_i_up(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_up, val)).unwrap();
    }
    pub fn get_i_up(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_up);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_up"))
    }
    pub fn set_i_up_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_up, val, mask)).unwrap();
    }
    pub fn get_i_up_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_up)
    }
    pub fn set_i_down(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_down, val)).unwrap();
    }
    pub fn get_i_down(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_down);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_down"))
    }
    pub fn set_i_down_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_down, val, mask)).unwrap();
    }
    pub fn get_i_down_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_down)
    }
    pub fn set_o_count_next(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_count_next, val)).unwrap();
    }
    pub fn get_o_count_next(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_count_next);
        val.try_into()
            .unwrap_or_else(|_| panic!("Value overflow for {}", "o_count_next"))
    }
    pub fn set_o_count_next_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_count_next, val, mask)).unwrap();
    }
    pub fn get_o_count_next_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_count_next)
    }
    pub fn set_i_set_value(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_set_value, val)).unwrap();
    }
    pub fn get_i_set_value(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_set_value);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_set_value"))
    }
    pub fn set_i_set_value_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_set_value, val, mask)).unwrap();
    }
    pub fn get_i_set_value_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_set_value)
    }
    pub fn bind<'a>(&'a self, sim: &'a mut celox::Simulator) -> counterBound<'a> {
        counterBound { sim, ids: self }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {
        sim.tick(self.i_clk).unwrap();
    }
}
pub struct counterBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a counter,
}
impl<'a> counterBound<'a> {
    pub fn set_i_set(&mut self, val: u8) {
        self.ids.set_i_set(self.sim, val);
    }
    pub fn get_i_set(&mut self) -> u8 {
        self.ids.get_i_set(self.sim)
    }
    pub fn set_i_set_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_set_4state(self.sim, val, mask);
    }
    pub fn get_i_set_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_set_4state(self.sim)
    }
    pub fn set_i_rst(&mut self, val: u8) {
        self.ids.set_i_rst(self.sim, val);
    }
    pub fn get_i_rst(&mut self) -> u8 {
        self.ids.get_i_rst(self.sim)
    }
    pub fn set_i_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_rst_4state(self.sim, val, mask);
    }
    pub fn get_i_rst_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_rst_4state(self.sim)
    }
    pub fn set_o_wrap_around(&mut self, val: u8) {
        self.ids.set_o_wrap_around(self.sim, val);
    }
    pub fn get_o_wrap_around(&mut self) -> u8 {
        self.ids.get_o_wrap_around(self.sim)
    }
    pub fn set_o_wrap_around_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.ids.set_o_wrap_around_4state(self.sim, val, mask);
    }
    pub fn get_o_wrap_around_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_wrap_around_4state(self.sim)
    }
    pub fn set_i_clear(&mut self, val: u8) {
        self.ids.set_i_clear(self.sim, val);
    }
    pub fn get_i_clear(&mut self) -> u8 {
        self.ids.get_i_clear(self.sim)
    }
    pub fn set_i_clear_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_clear_4state(self.sim, val, mask);
    }
    pub fn get_i_clear_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_clear_4state(self.sim)
    }
    pub fn set_o_count(&mut self, val: u8) {
        self.ids.set_o_count(self.sim, val);
    }
    pub fn get_o_count(&mut self) -> u8 {
        self.ids.get_o_count(self.sim)
    }
    pub fn set_o_count_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_count_4state(self.sim, val, mask);
    }
    pub fn get_o_count_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_count_4state(self.sim)
    }
    pub fn set_i_up(&mut self, val: u8) {
        self.ids.set_i_up(self.sim, val);
    }
    pub fn get_i_up(&mut self) -> u8 {
        self.ids.get_i_up(self.sim)
    }
    pub fn set_i_up_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_up_4state(self.sim, val, mask);
    }
    pub fn get_i_up_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_up_4state(self.sim)
    }
    pub fn set_i_down(&mut self, val: u8) {
        self.ids.set_i_down(self.sim, val);
    }
    pub fn get_i_down(&mut self) -> u8 {
        self.ids.get_i_down(self.sim)
    }
    pub fn set_i_down_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_down_4state(self.sim, val, mask);
    }
    pub fn get_i_down_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_down_4state(self.sim)
    }
    pub fn set_o_count_next(&mut self, val: u8) {
        self.ids.set_o_count_next(self.sim, val);
    }
    pub fn get_o_count_next(&mut self) -> u8 {
        self.ids.get_o_count_next(self.sim)
    }
    pub fn set_o_count_next_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.ids.set_o_count_next_4state(self.sim, val, mask);
    }
    pub fn get_o_count_next_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_count_next_4state(self.sim)
    }
    pub fn set_i_set_value(&mut self, val: u8) {
        self.ids.set_i_set_value(self.sim, val);
    }
    pub fn get_i_set_value(&mut self) -> u8 {
        self.ids.get_i_set_value(self.sim)
    }
    pub fn set_i_set_value_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_set_value_4state(self.sim, val, mask);
    }
    pub fn get_i_set_value_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_set_value_4state(self.sim)
    }
    pub fn tick(&mut self) {
        self.sim.tick(self.ids.i_clk).unwrap();
    }
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut counterIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = counterIO { io, ids: self.ids };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct counterIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a counter,
}
impl<'a, 'b> counterIO<'a, 'b> {
    pub fn set_i_set(&mut self, val: u8) {
        self.io.set(self.ids.i_set, val);
    }
    pub fn set_i_set_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_set, val, mask);
    }
    pub fn set_i_rst(&mut self, val: u8) {
        self.io.set(self.ids.i_rst, val);
    }
    pub fn set_i_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_rst, val, mask);
    }
    pub fn set_o_wrap_around(&mut self, val: u8) {
        self.io.set(self.ids.o_wrap_around, val);
    }
    pub fn set_o_wrap_around_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.io.set_four_state(self.ids.o_wrap_around, val, mask);
    }
    pub fn set_i_clear(&mut self, val: u8) {
        self.io.set(self.ids.i_clear, val);
    }
    pub fn set_i_clear_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_clear, val, mask);
    }
    pub fn set_o_count(&mut self, val: u8) {
        self.io.set(self.ids.o_count, val);
    }
    pub fn set_o_count_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_count, val, mask);
    }
    pub fn set_i_up(&mut self, val: u8) {
        self.io.set(self.ids.i_up, val);
    }
    pub fn set_i_up_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_up, val, mask);
    }
    pub fn set_i_down(&mut self, val: u8) {
        self.io.set(self.ids.i_down, val);
    }
    pub fn set_i_down_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_down, val, mask);
    }
    pub fn set_o_count_next(&mut self, val: u8) {
        self.io.set(self.ids.o_count_next, val);
    }
    pub fn set_o_count_next_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.io.set_four_state(self.ids.o_count_next, val, mask);
    }
    pub fn set_i_set_value(&mut self, val: u8) {
        self.io.set(self.ids.i_set_value, val);
    }
    pub fn set_i_set_value_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_set_value, val, mask);
    }
}
pub struct countones {
    pub i_data: celox::SignalRef,
    pub o_ones: celox::SignalRef,
}
impl countones {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            i_data: sim.signal("i_data"),
            o_ones: sim.signal("o_ones"),
        }
    }
    pub fn set_i_data(&self, sim: &mut celox::Simulator, val: u16) {
        sim.modify(|io| io.set(self.i_data, val)).unwrap();
    }
    pub fn get_i_data(&self, sim: &mut celox::Simulator) -> u16 {
        let val = sim.get(self.i_data);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_data"))
    }
    pub fn set_i_data_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_data, val, mask)).unwrap();
    }
    pub fn get_i_data_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_data)
    }
    pub fn set_o_ones(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_ones, val)).unwrap();
    }
    pub fn get_o_ones(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_ones);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_ones"))
    }
    pub fn set_o_ones_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_ones, val, mask)).unwrap();
    }
    pub fn get_o_ones_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_ones)
    }
    pub fn bind<'a>(&'a self, sim: &'a mut celox::Simulator) -> countonesBound<'a> {
        countonesBound { sim, ids: self }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {}
}
pub struct countonesBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a countones,
}
impl<'a> countonesBound<'a> {
    pub fn set_i_data(&mut self, val: u16) {
        self.ids.set_i_data(self.sim, val);
    }
    pub fn get_i_data(&mut self) -> u16 {
        self.ids.get_i_data(self.sim)
    }
    pub fn set_i_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_data_4state(self.sim, val, mask);
    }
    pub fn get_i_data_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_data_4state(self.sim)
    }
    pub fn set_o_ones(&mut self, val: u8) {
        self.ids.set_o_ones(self.sim, val);
    }
    pub fn get_o_ones(&mut self) -> u8 {
        self.ids.get_o_ones(self.sim)
    }
    pub fn set_o_ones_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_ones_4state(self.sim, val, mask);
    }
    pub fn get_o_ones_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_ones_4state(self.sim)
    }
    pub fn tick(&mut self) {}
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut countonesIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = countonesIO { io, ids: self.ids };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct countonesIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a countones,
}
impl<'a, 'b> countonesIO<'a, 'b> {
    pub fn set_i_data(&mut self, val: u16) {
        self.io.set(self.ids.i_data, val);
    }
    pub fn set_i_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_data, val, mask);
    }
    pub fn set_o_ones(&mut self, val: u8) {
        self.io.set(self.ids.o_ones, val);
    }
    pub fn set_o_ones_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_ones, val, mask);
    }
}
pub struct onehot {
    pub i_data: celox::SignalRef,
    pub o_onehot: celox::SignalRef,
    pub o_zero: celox::SignalRef,
}
impl onehot {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            i_data: sim.signal("i_data"),
            o_onehot: sim.signal("o_onehot"),
            o_zero: sim.signal("o_zero"),
        }
    }
    pub fn set_i_data(&self, sim: &mut celox::Simulator, val: u16) {
        sim.modify(|io| io.set(self.i_data, val)).unwrap();
    }
    pub fn get_i_data(&self, sim: &mut celox::Simulator) -> u16 {
        let val = sim.get(self.i_data);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_data"))
    }
    pub fn set_i_data_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_data, val, mask)).unwrap();
    }
    pub fn get_i_data_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_data)
    }
    pub fn set_o_onehot(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_onehot, val)).unwrap();
    }
    pub fn get_o_onehot(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_onehot);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_onehot"))
    }
    pub fn set_o_onehot_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_onehot, val, mask)).unwrap();
    }
    pub fn get_o_onehot_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_onehot)
    }
    pub fn set_o_zero(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_zero, val)).unwrap();
    }
    pub fn get_o_zero(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_zero);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_zero"))
    }
    pub fn set_o_zero_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_zero, val, mask)).unwrap();
    }
    pub fn get_o_zero_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_zero)
    }
    pub fn bind<'a>(&'a self, sim: &'a mut celox::Simulator) -> onehotBound<'a> {
        onehotBound { sim, ids: self }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {}
}
pub struct onehotBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a onehot,
}
impl<'a> onehotBound<'a> {
    pub fn set_i_data(&mut self, val: u16) {
        self.ids.set_i_data(self.sim, val);
    }
    pub fn get_i_data(&mut self) -> u16 {
        self.ids.get_i_data(self.sim)
    }
    pub fn set_i_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_data_4state(self.sim, val, mask);
    }
    pub fn get_i_data_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_data_4state(self.sim)
    }
    pub fn set_o_onehot(&mut self, val: u8) {
        self.ids.set_o_onehot(self.sim, val);
    }
    pub fn get_o_onehot(&mut self) -> u8 {
        self.ids.get_o_onehot(self.sim)
    }
    pub fn set_o_onehot_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_onehot_4state(self.sim, val, mask);
    }
    pub fn get_o_onehot_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_onehot_4state(self.sim)
    }
    pub fn set_o_zero(&mut self, val: u8) {
        self.ids.set_o_zero(self.sim, val);
    }
    pub fn get_o_zero(&mut self) -> u8 {
        self.ids.get_o_zero(self.sim)
    }
    pub fn set_o_zero_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_zero_4state(self.sim, val, mask);
    }
    pub fn get_o_zero_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_zero_4state(self.sim)
    }
    pub fn tick(&mut self) {}
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut onehotIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = onehotIO { io, ids: self.ids };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct onehotIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a onehot,
}
impl<'a, 'b> onehotIO<'a, 'b> {
    pub fn set_i_data(&mut self, val: u16) {
        self.io.set(self.ids.i_data, val);
    }
    pub fn set_i_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_data, val, mask);
    }
    pub fn set_o_onehot(&mut self, val: u8) {
        self.io.set(self.ids.o_onehot, val);
    }
    pub fn set_o_onehot_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_onehot, val, mask);
    }
    pub fn set_o_zero(&mut self, val: u8) {
        self.io.set(self.ids.o_zero, val);
    }
    pub fn set_o_zero_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_zero, val, mask);
    }
}
pub struct _onehot {
    pub o_zero: celox::SignalRef,
    pub o_gt_one: celox::SignalRef,
    pub i_data: celox::SignalRef,
    pub o_onehot: celox::SignalRef,
}
impl _onehot {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            o_zero: sim.signal("o_zero"),
            o_gt_one: sim.signal("o_gt_one"),
            i_data: sim.signal("i_data"),
            o_onehot: sim.signal("o_onehot"),
        }
    }
    pub fn set_o_zero(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_zero, val)).unwrap();
    }
    pub fn get_o_zero(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_zero);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_zero"))
    }
    pub fn set_o_zero_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_zero, val, mask)).unwrap();
    }
    pub fn get_o_zero_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_zero)
    }
    pub fn set_o_gt_one(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_gt_one, val)).unwrap();
    }
    pub fn get_o_gt_one(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_gt_one);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_gt_one"))
    }
    pub fn set_o_gt_one_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_gt_one, val, mask)).unwrap();
    }
    pub fn get_o_gt_one_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_gt_one)
    }
    pub fn set_i_data(&self, sim: &mut celox::Simulator, val: u16) {
        sim.modify(|io| io.set(self.i_data, val)).unwrap();
    }
    pub fn get_i_data(&self, sim: &mut celox::Simulator) -> u16 {
        let val = sim.get(self.i_data);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_data"))
    }
    pub fn set_i_data_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_data, val, mask)).unwrap();
    }
    pub fn get_i_data_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_data)
    }
    pub fn set_o_onehot(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_onehot, val)).unwrap();
    }
    pub fn get_o_onehot(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_onehot);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_onehot"))
    }
    pub fn set_o_onehot_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_onehot, val, mask)).unwrap();
    }
    pub fn get_o_onehot_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_onehot)
    }
    pub fn bind<'a>(&'a self, sim: &'a mut celox::Simulator) -> _onehotBound<'a> {
        _onehotBound { sim, ids: self }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {}
}
pub struct _onehotBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a _onehot,
}
impl<'a> _onehotBound<'a> {
    pub fn set_o_zero(&mut self, val: u8) {
        self.ids.set_o_zero(self.sim, val);
    }
    pub fn get_o_zero(&mut self) -> u8 {
        self.ids.get_o_zero(self.sim)
    }
    pub fn set_o_zero_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_zero_4state(self.sim, val, mask);
    }
    pub fn get_o_zero_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_zero_4state(self.sim)
    }
    pub fn set_o_gt_one(&mut self, val: u8) {
        self.ids.set_o_gt_one(self.sim, val);
    }
    pub fn get_o_gt_one(&mut self) -> u8 {
        self.ids.get_o_gt_one(self.sim)
    }
    pub fn set_o_gt_one_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_gt_one_4state(self.sim, val, mask);
    }
    pub fn get_o_gt_one_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_gt_one_4state(self.sim)
    }
    pub fn set_i_data(&mut self, val: u16) {
        self.ids.set_i_data(self.sim, val);
    }
    pub fn get_i_data(&mut self) -> u16 {
        self.ids.get_i_data(self.sim)
    }
    pub fn set_i_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_data_4state(self.sim, val, mask);
    }
    pub fn get_i_data_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_data_4state(self.sim)
    }
    pub fn set_o_onehot(&mut self, val: u8) {
        self.ids.set_o_onehot(self.sim, val);
    }
    pub fn get_o_onehot(&mut self) -> u8 {
        self.ids.get_o_onehot(self.sim)
    }
    pub fn set_o_onehot_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_onehot_4state(self.sim, val, mask);
    }
    pub fn get_o_onehot_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_onehot_4state(self.sim)
    }
    pub fn tick(&mut self) {}
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut _onehotIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = _onehotIO { io, ids: self.ids };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct _onehotIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a _onehot,
}
impl<'a, 'b> _onehotIO<'a, 'b> {
    pub fn set_o_zero(&mut self, val: u8) {
        self.io.set(self.ids.o_zero, val);
    }
    pub fn set_o_zero_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_zero, val, mask);
    }
    pub fn set_o_gt_one(&mut self, val: u8) {
        self.io.set(self.ids.o_gt_one, val);
    }
    pub fn set_o_gt_one_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_gt_one, val, mask);
    }
    pub fn set_i_data(&mut self, val: u16) {
        self.io.set(self.ids.i_data, val);
    }
    pub fn set_i_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_data, val, mask);
    }
    pub fn set_o_onehot(&mut self, val: u8) {
        self.io.set(self.ids.o_onehot, val);
    }
    pub fn set_o_onehot_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_onehot, val, mask);
    }
}
pub struct delay {
    pub i_clk: celox::EventRef,
    pub o_d: celox::SignalRef,
    pub i_rst: celox::SignalRef,
    pub i_d: celox::SignalRef,
}
impl delay {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            i_clk: sim.event("i_clk"),
            o_d: sim.signal("o_d"),
            i_rst: sim.signal("i_rst"),
            i_d: sim.signal("i_d"),
        }
    }
    pub fn set_o_d(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_d, val)).unwrap();
    }
    pub fn get_o_d(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_d);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_d"))
    }
    pub fn set_o_d_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_d, val, mask)).unwrap();
    }
    pub fn get_o_d_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_d)
    }
    pub fn set_i_rst(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_rst, val)).unwrap();
    }
    pub fn get_i_rst(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_rst);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_rst"))
    }
    pub fn set_i_rst_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_rst, val, mask)).unwrap();
    }
    pub fn get_i_rst_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_rst)
    }
    pub fn set_i_d(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_d, val)).unwrap();
    }
    pub fn get_i_d(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_d);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_d"))
    }
    pub fn set_i_d_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_d, val, mask)).unwrap();
    }
    pub fn get_i_d_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_d)
    }
    pub fn bind<'a>(&'a self, sim: &'a mut celox::Simulator) -> delayBound<'a> {
        delayBound { sim, ids: self }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {
        sim.tick(self.i_clk).unwrap();
    }
}
pub struct delayBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a delay,
}
impl<'a> delayBound<'a> {
    pub fn set_o_d(&mut self, val: u8) {
        self.ids.set_o_d(self.sim, val);
    }
    pub fn get_o_d(&mut self) -> u8 {
        self.ids.get_o_d(self.sim)
    }
    pub fn set_o_d_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_d_4state(self.sim, val, mask);
    }
    pub fn get_o_d_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_d_4state(self.sim)
    }
    pub fn set_i_rst(&mut self, val: u8) {
        self.ids.set_i_rst(self.sim, val);
    }
    pub fn get_i_rst(&mut self) -> u8 {
        self.ids.get_i_rst(self.sim)
    }
    pub fn set_i_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_rst_4state(self.sim, val, mask);
    }
    pub fn get_i_rst_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_rst_4state(self.sim)
    }
    pub fn set_i_d(&mut self, val: u8) {
        self.ids.set_i_d(self.sim, val);
    }
    pub fn get_i_d(&mut self) -> u8 {
        self.ids.get_i_d(self.sim)
    }
    pub fn set_i_d_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_d_4state(self.sim, val, mask);
    }
    pub fn get_i_d_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_d_4state(self.sim)
    }
    pub fn tick(&mut self) {
        self.sim.tick(self.ids.i_clk).unwrap();
    }
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut delayIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = delayIO { io, ids: self.ids };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct delayIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a delay,
}
impl<'a, 'b> delayIO<'a, 'b> {
    pub fn set_o_d(&mut self, val: u8) {
        self.io.set(self.ids.o_d, val);
    }
    pub fn set_o_d_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_d, val, mask);
    }
    pub fn set_i_rst(&mut self, val: u8) {
        self.io.set(self.ids.i_rst, val);
    }
    pub fn set_i_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_rst, val, mask);
    }
    pub fn set_i_d(&mut self, val: u8) {
        self.io.set(self.ids.i_d, val);
    }
    pub fn set_i_d_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_d, val, mask);
    }
}
pub struct edge_detector {
    pub i_clear: celox::SignalRef,
    pub i_clk: celox::EventRef,
    pub o_posedge: celox::SignalRef,
    pub o_negedge: celox::SignalRef,
    pub i_data: celox::SignalRef,
    pub o_edge: celox::SignalRef,
    pub i_rst: celox::SignalRef,
}
impl edge_detector {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            i_clear: sim.signal("i_clear"),
            i_clk: sim.event("i_clk"),
            o_posedge: sim.signal("o_posedge"),
            o_negedge: sim.signal("o_negedge"),
            i_data: sim.signal("i_data"),
            o_edge: sim.signal("o_edge"),
            i_rst: sim.signal("i_rst"),
        }
    }
    pub fn set_i_clear(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_clear, val)).unwrap();
    }
    pub fn get_i_clear(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_clear);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_clear"))
    }
    pub fn set_i_clear_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_clear, val, mask)).unwrap();
    }
    pub fn get_i_clear_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_clear)
    }
    pub fn set_o_posedge(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_posedge, val)).unwrap();
    }
    pub fn get_o_posedge(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_posedge);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_posedge"))
    }
    pub fn set_o_posedge_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_posedge, val, mask)).unwrap();
    }
    pub fn get_o_posedge_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_posedge)
    }
    pub fn set_o_negedge(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_negedge, val)).unwrap();
    }
    pub fn get_o_negedge(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_negedge);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_negedge"))
    }
    pub fn set_o_negedge_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_negedge, val, mask)).unwrap();
    }
    pub fn get_o_negedge_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_negedge)
    }
    pub fn set_i_data(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_data, val)).unwrap();
    }
    pub fn get_i_data(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_data);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_data"))
    }
    pub fn set_i_data_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_data, val, mask)).unwrap();
    }
    pub fn get_i_data_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_data)
    }
    pub fn set_o_edge(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_edge, val)).unwrap();
    }
    pub fn get_o_edge(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_edge);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_edge"))
    }
    pub fn set_o_edge_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_edge, val, mask)).unwrap();
    }
    pub fn get_o_edge_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_edge)
    }
    pub fn set_i_rst(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_rst, val)).unwrap();
    }
    pub fn get_i_rst(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_rst);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_rst"))
    }
    pub fn set_i_rst_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_rst, val, mask)).unwrap();
    }
    pub fn get_i_rst_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_rst)
    }
    pub fn bind<'a>(&'a self, sim: &'a mut celox::Simulator) -> edge_detectorBound<'a> {
        edge_detectorBound {
            sim,
            ids: self,
        }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {
        sim.tick(self.i_clk).unwrap();
    }
}
pub struct edge_detectorBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a edge_detector,
}
impl<'a> edge_detectorBound<'a> {
    pub fn set_i_clear(&mut self, val: u8) {
        self.ids.set_i_clear(self.sim, val);
    }
    pub fn get_i_clear(&mut self) -> u8 {
        self.ids.get_i_clear(self.sim)
    }
    pub fn set_i_clear_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_clear_4state(self.sim, val, mask);
    }
    pub fn get_i_clear_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_clear_4state(self.sim)
    }
    pub fn set_o_posedge(&mut self, val: u8) {
        self.ids.set_o_posedge(self.sim, val);
    }
    pub fn get_o_posedge(&mut self) -> u8 {
        self.ids.get_o_posedge(self.sim)
    }
    pub fn set_o_posedge_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_posedge_4state(self.sim, val, mask);
    }
    pub fn get_o_posedge_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_posedge_4state(self.sim)
    }
    pub fn set_o_negedge(&mut self, val: u8) {
        self.ids.set_o_negedge(self.sim, val);
    }
    pub fn get_o_negedge(&mut self) -> u8 {
        self.ids.get_o_negedge(self.sim)
    }
    pub fn set_o_negedge_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_negedge_4state(self.sim, val, mask);
    }
    pub fn get_o_negedge_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_negedge_4state(self.sim)
    }
    pub fn set_i_data(&mut self, val: u8) {
        self.ids.set_i_data(self.sim, val);
    }
    pub fn get_i_data(&mut self) -> u8 {
        self.ids.get_i_data(self.sim)
    }
    pub fn set_i_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_data_4state(self.sim, val, mask);
    }
    pub fn get_i_data_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_data_4state(self.sim)
    }
    pub fn set_o_edge(&mut self, val: u8) {
        self.ids.set_o_edge(self.sim, val);
    }
    pub fn get_o_edge(&mut self) -> u8 {
        self.ids.get_o_edge(self.sim)
    }
    pub fn set_o_edge_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_edge_4state(self.sim, val, mask);
    }
    pub fn get_o_edge_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_edge_4state(self.sim)
    }
    pub fn set_i_rst(&mut self, val: u8) {
        self.ids.set_i_rst(self.sim, val);
    }
    pub fn get_i_rst(&mut self) -> u8 {
        self.ids.get_i_rst(self.sim)
    }
    pub fn set_i_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_rst_4state(self.sim, val, mask);
    }
    pub fn get_i_rst_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_rst_4state(self.sim)
    }
    pub fn tick(&mut self) {
        self.sim.tick(self.ids.i_clk).unwrap();
    }
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut edge_detectorIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = edge_detectorIO {
                    io,
                    ids: self.ids,
                };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct edge_detectorIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a edge_detector,
}
impl<'a, 'b> edge_detectorIO<'a, 'b> {
    pub fn set_i_clear(&mut self, val: u8) {
        self.io.set(self.ids.i_clear, val);
    }
    pub fn set_i_clear_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_clear, val, mask);
    }
    pub fn set_o_posedge(&mut self, val: u8) {
        self.io.set(self.ids.o_posedge, val);
    }
    pub fn set_o_posedge_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_posedge, val, mask);
    }
    pub fn set_o_negedge(&mut self, val: u8) {
        self.io.set(self.ids.o_negedge, val);
    }
    pub fn set_o_negedge_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_negedge, val, mask);
    }
    pub fn set_i_data(&mut self, val: u8) {
        self.io.set(self.ids.i_data, val);
    }
    pub fn set_i_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_data, val, mask);
    }
    pub fn set_o_edge(&mut self, val: u8) {
        self.io.set(self.ids.o_edge, val);
    }
    pub fn set_o_edge_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_edge, val, mask);
    }
    pub fn set_i_rst(&mut self, val: u8) {
        self.io.set(self.ids.i_rst, val);
    }
    pub fn set_i_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_rst, val, mask);
    }
}
pub struct fifo {
    pub o_empty: celox::SignalRef,
    pub i_clk: celox::EventRef,
    pub o_data: celox::SignalRef,
    pub o_word_count: celox::SignalRef,
    pub i_push: celox::SignalRef,
    pub o_almost_full: celox::SignalRef,
    pub i_rst: celox::SignalRef,
    pub i_clear: celox::SignalRef,
    pub i_pop: celox::SignalRef,
    pub i_data: celox::SignalRef,
    pub o_full: celox::SignalRef,
}
impl fifo {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            o_empty: sim.signal("o_empty"),
            i_clk: sim.event("i_clk"),
            o_data: sim.signal("o_data"),
            o_word_count: sim.signal("o_word_count"),
            i_push: sim.signal("i_push"),
            o_almost_full: sim.signal("o_almost_full"),
            i_rst: sim.signal("i_rst"),
            i_clear: sim.signal("i_clear"),
            i_pop: sim.signal("i_pop"),
            i_data: sim.signal("i_data"),
            o_full: sim.signal("o_full"),
        }
    }
    pub fn set_o_empty(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_empty, val)).unwrap();
    }
    pub fn get_o_empty(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_empty);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_empty"))
    }
    pub fn set_o_empty_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_empty, val, mask)).unwrap();
    }
    pub fn get_o_empty_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_empty)
    }
    pub fn set_o_data(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_data, val)).unwrap();
    }
    pub fn get_o_data(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_data);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_data"))
    }
    pub fn set_o_data_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_data, val, mask)).unwrap();
    }
    pub fn get_o_data_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_data)
    }
    pub fn set_o_word_count(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_word_count, val)).unwrap();
    }
    pub fn get_o_word_count(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_word_count);
        val.try_into()
            .unwrap_or_else(|_| panic!("Value overflow for {}", "o_word_count"))
    }
    pub fn set_o_word_count_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_word_count, val, mask)).unwrap();
    }
    pub fn get_o_word_count_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_word_count)
    }
    pub fn set_i_push(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_push, val)).unwrap();
    }
    pub fn get_i_push(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_push);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_push"))
    }
    pub fn set_i_push_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_push, val, mask)).unwrap();
    }
    pub fn get_i_push_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_push)
    }
    pub fn set_o_almost_full(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_almost_full, val)).unwrap();
    }
    pub fn get_o_almost_full(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_almost_full);
        val.try_into()
            .unwrap_or_else(|_| panic!("Value overflow for {}", "o_almost_full"))
    }
    pub fn set_o_almost_full_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_almost_full, val, mask)).unwrap();
    }
    pub fn get_o_almost_full_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_almost_full)
    }
    pub fn set_i_rst(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_rst, val)).unwrap();
    }
    pub fn get_i_rst(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_rst);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_rst"))
    }
    pub fn set_i_rst_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_rst, val, mask)).unwrap();
    }
    pub fn get_i_rst_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_rst)
    }
    pub fn set_i_clear(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_clear, val)).unwrap();
    }
    pub fn get_i_clear(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_clear);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_clear"))
    }
    pub fn set_i_clear_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_clear, val, mask)).unwrap();
    }
    pub fn get_i_clear_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_clear)
    }
    pub fn set_i_pop(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_pop, val)).unwrap();
    }
    pub fn get_i_pop(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_pop);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_pop"))
    }
    pub fn set_i_pop_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_pop, val, mask)).unwrap();
    }
    pub fn get_i_pop_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_pop)
    }
    pub fn set_i_data(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_data, val)).unwrap();
    }
    pub fn get_i_data(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_data);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_data"))
    }
    pub fn set_i_data_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_data, val, mask)).unwrap();
    }
    pub fn get_i_data_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_data)
    }
    pub fn set_o_full(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_full, val)).unwrap();
    }
    pub fn get_o_full(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_full);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_full"))
    }
    pub fn set_o_full_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_full, val, mask)).unwrap();
    }
    pub fn get_o_full_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_full)
    }
    pub fn bind<'a>(&'a self, sim: &'a mut celox::Simulator) -> fifoBound<'a> {
        fifoBound { sim, ids: self }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {
        sim.tick(self.i_clk).unwrap();
    }
}
pub struct fifoBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a fifo,
}
impl<'a> fifoBound<'a> {
    pub fn set_o_empty(&mut self, val: u8) {
        self.ids.set_o_empty(self.sim, val);
    }
    pub fn get_o_empty(&mut self) -> u8 {
        self.ids.get_o_empty(self.sim)
    }
    pub fn set_o_empty_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_empty_4state(self.sim, val, mask);
    }
    pub fn get_o_empty_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_empty_4state(self.sim)
    }
    pub fn set_o_data(&mut self, val: u8) {
        self.ids.set_o_data(self.sim, val);
    }
    pub fn get_o_data(&mut self) -> u8 {
        self.ids.get_o_data(self.sim)
    }
    pub fn set_o_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_data_4state(self.sim, val, mask);
    }
    pub fn get_o_data_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_data_4state(self.sim)
    }
    pub fn set_o_word_count(&mut self, val: u8) {
        self.ids.set_o_word_count(self.sim, val);
    }
    pub fn get_o_word_count(&mut self) -> u8 {
        self.ids.get_o_word_count(self.sim)
    }
    pub fn set_o_word_count_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.ids.set_o_word_count_4state(self.sim, val, mask);
    }
    pub fn get_o_word_count_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_word_count_4state(self.sim)
    }
    pub fn set_i_push(&mut self, val: u8) {
        self.ids.set_i_push(self.sim, val);
    }
    pub fn get_i_push(&mut self) -> u8 {
        self.ids.get_i_push(self.sim)
    }
    pub fn set_i_push_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_push_4state(self.sim, val, mask);
    }
    pub fn get_i_push_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_push_4state(self.sim)
    }
    pub fn set_o_almost_full(&mut self, val: u8) {
        self.ids.set_o_almost_full(self.sim, val);
    }
    pub fn get_o_almost_full(&mut self) -> u8 {
        self.ids.get_o_almost_full(self.sim)
    }
    pub fn set_o_almost_full_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.ids.set_o_almost_full_4state(self.sim, val, mask);
    }
    pub fn get_o_almost_full_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_almost_full_4state(self.sim)
    }
    pub fn set_i_rst(&mut self, val: u8) {
        self.ids.set_i_rst(self.sim, val);
    }
    pub fn get_i_rst(&mut self) -> u8 {
        self.ids.get_i_rst(self.sim)
    }
    pub fn set_i_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_rst_4state(self.sim, val, mask);
    }
    pub fn get_i_rst_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_rst_4state(self.sim)
    }
    pub fn set_i_clear(&mut self, val: u8) {
        self.ids.set_i_clear(self.sim, val);
    }
    pub fn get_i_clear(&mut self) -> u8 {
        self.ids.get_i_clear(self.sim)
    }
    pub fn set_i_clear_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_clear_4state(self.sim, val, mask);
    }
    pub fn get_i_clear_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_clear_4state(self.sim)
    }
    pub fn set_i_pop(&mut self, val: u8) {
        self.ids.set_i_pop(self.sim, val);
    }
    pub fn get_i_pop(&mut self) -> u8 {
        self.ids.get_i_pop(self.sim)
    }
    pub fn set_i_pop_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_pop_4state(self.sim, val, mask);
    }
    pub fn get_i_pop_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_pop_4state(self.sim)
    }
    pub fn set_i_data(&mut self, val: u8) {
        self.ids.set_i_data(self.sim, val);
    }
    pub fn get_i_data(&mut self) -> u8 {
        self.ids.get_i_data(self.sim)
    }
    pub fn set_i_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_data_4state(self.sim, val, mask);
    }
    pub fn get_i_data_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_data_4state(self.sim)
    }
    pub fn set_o_full(&mut self, val: u8) {
        self.ids.set_o_full(self.sim, val);
    }
    pub fn get_o_full(&mut self) -> u8 {
        self.ids.get_o_full(self.sim)
    }
    pub fn set_o_full_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_full_4state(self.sim, val, mask);
    }
    pub fn get_o_full_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_full_4state(self.sim)
    }
    pub fn tick(&mut self) {
        self.sim.tick(self.ids.i_clk).unwrap();
    }
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut fifoIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = fifoIO { io, ids: self.ids };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct fifoIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a fifo,
}
impl<'a, 'b> fifoIO<'a, 'b> {
    pub fn set_o_empty(&mut self, val: u8) {
        self.io.set(self.ids.o_empty, val);
    }
    pub fn set_o_empty_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_empty, val, mask);
    }
    pub fn set_o_data(&mut self, val: u8) {
        self.io.set(self.ids.o_data, val);
    }
    pub fn set_o_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_data, val, mask);
    }
    pub fn set_o_word_count(&mut self, val: u8) {
        self.io.set(self.ids.o_word_count, val);
    }
    pub fn set_o_word_count_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.io.set_four_state(self.ids.o_word_count, val, mask);
    }
    pub fn set_i_push(&mut self, val: u8) {
        self.io.set(self.ids.i_push, val);
    }
    pub fn set_i_push_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_push, val, mask);
    }
    pub fn set_o_almost_full(&mut self, val: u8) {
        self.io.set(self.ids.o_almost_full, val);
    }
    pub fn set_o_almost_full_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.io.set_four_state(self.ids.o_almost_full, val, mask);
    }
    pub fn set_i_rst(&mut self, val: u8) {
        self.io.set(self.ids.i_rst, val);
    }
    pub fn set_i_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_rst, val, mask);
    }
    pub fn set_i_clear(&mut self, val: u8) {
        self.io.set(self.ids.i_clear, val);
    }
    pub fn set_i_clear_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_clear, val, mask);
    }
    pub fn set_i_pop(&mut self, val: u8) {
        self.io.set(self.ids.i_pop, val);
    }
    pub fn set_i_pop_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_pop, val, mask);
    }
    pub fn set_i_data(&mut self, val: u8) {
        self.io.set(self.ids.i_data, val);
    }
    pub fn set_i_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_data, val, mask);
    }
    pub fn set_o_full(&mut self, val: u8) {
        self.io.set(self.ids.o_full, val);
    }
    pub fn set_o_full_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_full, val, mask);
    }
}
pub struct fifo_controller {
    pub o_read_pointer: celox::SignalRef,
    pub o_word_count: celox::SignalRef,
    pub i_push: celox::SignalRef,
    pub o_almost_full: celox::SignalRef,
    pub i_rst: celox::SignalRef,
    pub i_clear: celox::SignalRef,
    pub o_write_to_ram: celox::SignalRef,
    pub o_full: celox::SignalRef,
    pub o_empty: celox::SignalRef,
    pub i_clk: celox::EventRef,
    pub o_write_pointer: celox::SignalRef,
    pub o_write_to_ff: celox::SignalRef,
    pub i_pop: celox::SignalRef,
    pub o_read_from_ram: celox::SignalRef,
    pub i_data: celox::SignalRef,
}
impl fifo_controller {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            o_read_pointer: sim.signal("o_read_pointer"),
            o_word_count: sim.signal("o_word_count"),
            i_push: sim.signal("i_push"),
            o_almost_full: sim.signal("o_almost_full"),
            i_rst: sim.signal("i_rst"),
            i_clear: sim.signal("i_clear"),
            o_write_to_ram: sim.signal("o_write_to_ram"),
            o_full: sim.signal("o_full"),
            o_empty: sim.signal("o_empty"),
            i_clk: sim.event("i_clk"),
            o_write_pointer: sim.signal("o_write_pointer"),
            o_write_to_ff: sim.signal("o_write_to_ff"),
            i_pop: sim.signal("i_pop"),
            o_read_from_ram: sim.signal("o_read_from_ram"),
            i_data: sim.signal("i_data"),
        }
    }
    pub fn set_o_read_pointer(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_read_pointer, val)).unwrap();
    }
    pub fn get_o_read_pointer(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_read_pointer);
        val.try_into()
            .unwrap_or_else(|_| panic!("Value overflow for {}", "o_read_pointer"))
    }
    pub fn set_o_read_pointer_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_read_pointer, val, mask)).unwrap();
    }
    pub fn get_o_read_pointer_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_read_pointer)
    }
    pub fn set_o_word_count(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_word_count, val)).unwrap();
    }
    pub fn get_o_word_count(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_word_count);
        val.try_into()
            .unwrap_or_else(|_| panic!("Value overflow for {}", "o_word_count"))
    }
    pub fn set_o_word_count_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_word_count, val, mask)).unwrap();
    }
    pub fn get_o_word_count_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_word_count)
    }
    pub fn set_i_push(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_push, val)).unwrap();
    }
    pub fn get_i_push(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_push);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_push"))
    }
    pub fn set_i_push_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_push, val, mask)).unwrap();
    }
    pub fn get_i_push_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_push)
    }
    pub fn set_o_almost_full(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_almost_full, val)).unwrap();
    }
    pub fn get_o_almost_full(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_almost_full);
        val.try_into()
            .unwrap_or_else(|_| panic!("Value overflow for {}", "o_almost_full"))
    }
    pub fn set_o_almost_full_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_almost_full, val, mask)).unwrap();
    }
    pub fn get_o_almost_full_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_almost_full)
    }
    pub fn set_i_rst(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_rst, val)).unwrap();
    }
    pub fn get_i_rst(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_rst);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_rst"))
    }
    pub fn set_i_rst_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_rst, val, mask)).unwrap();
    }
    pub fn get_i_rst_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_rst)
    }
    pub fn set_i_clear(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_clear, val)).unwrap();
    }
    pub fn get_i_clear(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_clear);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_clear"))
    }
    pub fn set_i_clear_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_clear, val, mask)).unwrap();
    }
    pub fn get_i_clear_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_clear)
    }
    pub fn set_o_write_to_ram(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_write_to_ram, val)).unwrap();
    }
    pub fn get_o_write_to_ram(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_write_to_ram);
        val.try_into()
            .unwrap_or_else(|_| panic!("Value overflow for {}", "o_write_to_ram"))
    }
    pub fn set_o_write_to_ram_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_write_to_ram, val, mask)).unwrap();
    }
    pub fn get_o_write_to_ram_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_write_to_ram)
    }
    pub fn set_o_full(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_full, val)).unwrap();
    }
    pub fn get_o_full(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_full);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_full"))
    }
    pub fn set_o_full_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_full, val, mask)).unwrap();
    }
    pub fn get_o_full_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_full)
    }
    pub fn set_o_empty(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_empty, val)).unwrap();
    }
    pub fn get_o_empty(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_empty);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_empty"))
    }
    pub fn set_o_empty_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_empty, val, mask)).unwrap();
    }
    pub fn get_o_empty_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_empty)
    }
    pub fn set_o_write_pointer(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_write_pointer, val)).unwrap();
    }
    pub fn get_o_write_pointer(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_write_pointer);
        val.try_into()
            .unwrap_or_else(|_| panic!("Value overflow for {}", "o_write_pointer"))
    }
    pub fn set_o_write_pointer_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_write_pointer, val, mask)).unwrap();
    }
    pub fn get_o_write_pointer_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_write_pointer)
    }
    pub fn set_o_write_to_ff(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_write_to_ff, val)).unwrap();
    }
    pub fn get_o_write_to_ff(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_write_to_ff);
        val.try_into()
            .unwrap_or_else(|_| panic!("Value overflow for {}", "o_write_to_ff"))
    }
    pub fn set_o_write_to_ff_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_write_to_ff, val, mask)).unwrap();
    }
    pub fn get_o_write_to_ff_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_write_to_ff)
    }
    pub fn set_i_pop(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_pop, val)).unwrap();
    }
    pub fn get_i_pop(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_pop);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_pop"))
    }
    pub fn set_i_pop_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_pop, val, mask)).unwrap();
    }
    pub fn get_i_pop_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_pop)
    }
    pub fn set_o_read_from_ram(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_read_from_ram, val)).unwrap();
    }
    pub fn get_o_read_from_ram(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_read_from_ram);
        val.try_into()
            .unwrap_or_else(|_| panic!("Value overflow for {}", "o_read_from_ram"))
    }
    pub fn set_o_read_from_ram_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_read_from_ram, val, mask)).unwrap();
    }
    pub fn get_o_read_from_ram_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_read_from_ram)
    }
    pub fn set_i_data(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_data, val)).unwrap();
    }
    pub fn get_i_data(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_data);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_data"))
    }
    pub fn set_i_data_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_data, val, mask)).unwrap();
    }
    pub fn get_i_data_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_data)
    }
    pub fn bind<'a>(
        &'a self,
        sim: &'a mut celox::Simulator,
    ) -> fifo_controllerBound<'a> {
        fifo_controllerBound {
            sim,
            ids: self,
        }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {
        sim.tick(self.i_clk).unwrap();
    }
}
pub struct fifo_controllerBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a fifo_controller,
}
impl<'a> fifo_controllerBound<'a> {
    pub fn set_o_read_pointer(&mut self, val: u8) {
        self.ids.set_o_read_pointer(self.sim, val);
    }
    pub fn get_o_read_pointer(&mut self) -> u8 {
        self.ids.get_o_read_pointer(self.sim)
    }
    pub fn set_o_read_pointer_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.ids.set_o_read_pointer_4state(self.sim, val, mask);
    }
    pub fn get_o_read_pointer_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_read_pointer_4state(self.sim)
    }
    pub fn set_o_word_count(&mut self, val: u8) {
        self.ids.set_o_word_count(self.sim, val);
    }
    pub fn get_o_word_count(&mut self) -> u8 {
        self.ids.get_o_word_count(self.sim)
    }
    pub fn set_o_word_count_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.ids.set_o_word_count_4state(self.sim, val, mask);
    }
    pub fn get_o_word_count_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_word_count_4state(self.sim)
    }
    pub fn set_i_push(&mut self, val: u8) {
        self.ids.set_i_push(self.sim, val);
    }
    pub fn get_i_push(&mut self) -> u8 {
        self.ids.get_i_push(self.sim)
    }
    pub fn set_i_push_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_push_4state(self.sim, val, mask);
    }
    pub fn get_i_push_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_push_4state(self.sim)
    }
    pub fn set_o_almost_full(&mut self, val: u8) {
        self.ids.set_o_almost_full(self.sim, val);
    }
    pub fn get_o_almost_full(&mut self) -> u8 {
        self.ids.get_o_almost_full(self.sim)
    }
    pub fn set_o_almost_full_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.ids.set_o_almost_full_4state(self.sim, val, mask);
    }
    pub fn get_o_almost_full_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_almost_full_4state(self.sim)
    }
    pub fn set_i_rst(&mut self, val: u8) {
        self.ids.set_i_rst(self.sim, val);
    }
    pub fn get_i_rst(&mut self) -> u8 {
        self.ids.get_i_rst(self.sim)
    }
    pub fn set_i_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_rst_4state(self.sim, val, mask);
    }
    pub fn get_i_rst_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_rst_4state(self.sim)
    }
    pub fn set_i_clear(&mut self, val: u8) {
        self.ids.set_i_clear(self.sim, val);
    }
    pub fn get_i_clear(&mut self) -> u8 {
        self.ids.get_i_clear(self.sim)
    }
    pub fn set_i_clear_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_clear_4state(self.sim, val, mask);
    }
    pub fn get_i_clear_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_clear_4state(self.sim)
    }
    pub fn set_o_write_to_ram(&mut self, val: u8) {
        self.ids.set_o_write_to_ram(self.sim, val);
    }
    pub fn get_o_write_to_ram(&mut self) -> u8 {
        self.ids.get_o_write_to_ram(self.sim)
    }
    pub fn set_o_write_to_ram_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.ids.set_o_write_to_ram_4state(self.sim, val, mask);
    }
    pub fn get_o_write_to_ram_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_write_to_ram_4state(self.sim)
    }
    pub fn set_o_full(&mut self, val: u8) {
        self.ids.set_o_full(self.sim, val);
    }
    pub fn get_o_full(&mut self) -> u8 {
        self.ids.get_o_full(self.sim)
    }
    pub fn set_o_full_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_full_4state(self.sim, val, mask);
    }
    pub fn get_o_full_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_full_4state(self.sim)
    }
    pub fn set_o_empty(&mut self, val: u8) {
        self.ids.set_o_empty(self.sim, val);
    }
    pub fn get_o_empty(&mut self) -> u8 {
        self.ids.get_o_empty(self.sim)
    }
    pub fn set_o_empty_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_empty_4state(self.sim, val, mask);
    }
    pub fn get_o_empty_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_empty_4state(self.sim)
    }
    pub fn set_o_write_pointer(&mut self, val: u8) {
        self.ids.set_o_write_pointer(self.sim, val);
    }
    pub fn get_o_write_pointer(&mut self) -> u8 {
        self.ids.get_o_write_pointer(self.sim)
    }
    pub fn set_o_write_pointer_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.ids.set_o_write_pointer_4state(self.sim, val, mask);
    }
    pub fn get_o_write_pointer_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_write_pointer_4state(self.sim)
    }
    pub fn set_o_write_to_ff(&mut self, val: u8) {
        self.ids.set_o_write_to_ff(self.sim, val);
    }
    pub fn get_o_write_to_ff(&mut self) -> u8 {
        self.ids.get_o_write_to_ff(self.sim)
    }
    pub fn set_o_write_to_ff_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.ids.set_o_write_to_ff_4state(self.sim, val, mask);
    }
    pub fn get_o_write_to_ff_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_write_to_ff_4state(self.sim)
    }
    pub fn set_i_pop(&mut self, val: u8) {
        self.ids.set_i_pop(self.sim, val);
    }
    pub fn get_i_pop(&mut self) -> u8 {
        self.ids.get_i_pop(self.sim)
    }
    pub fn set_i_pop_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_pop_4state(self.sim, val, mask);
    }
    pub fn get_i_pop_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_pop_4state(self.sim)
    }
    pub fn set_o_read_from_ram(&mut self, val: u8) {
        self.ids.set_o_read_from_ram(self.sim, val);
    }
    pub fn get_o_read_from_ram(&mut self) -> u8 {
        self.ids.get_o_read_from_ram(self.sim)
    }
    pub fn set_o_read_from_ram_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.ids.set_o_read_from_ram_4state(self.sim, val, mask);
    }
    pub fn get_o_read_from_ram_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_read_from_ram_4state(self.sim)
    }
    pub fn set_i_data(&mut self, val: u8) {
        self.ids.set_i_data(self.sim, val);
    }
    pub fn get_i_data(&mut self) -> u8 {
        self.ids.get_i_data(self.sim)
    }
    pub fn set_i_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_data_4state(self.sim, val, mask);
    }
    pub fn get_i_data_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_data_4state(self.sim)
    }
    pub fn tick(&mut self) {
        self.sim.tick(self.ids.i_clk).unwrap();
    }
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut fifo_controllerIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = fifo_controllerIO {
                    io,
                    ids: self.ids,
                };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct fifo_controllerIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a fifo_controller,
}
impl<'a, 'b> fifo_controllerIO<'a, 'b> {
    pub fn set_o_read_pointer(&mut self, val: u8) {
        self.io.set(self.ids.o_read_pointer, val);
    }
    pub fn set_o_read_pointer_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.io.set_four_state(self.ids.o_read_pointer, val, mask);
    }
    pub fn set_o_word_count(&mut self, val: u8) {
        self.io.set(self.ids.o_word_count, val);
    }
    pub fn set_o_word_count_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.io.set_four_state(self.ids.o_word_count, val, mask);
    }
    pub fn set_i_push(&mut self, val: u8) {
        self.io.set(self.ids.i_push, val);
    }
    pub fn set_i_push_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_push, val, mask);
    }
    pub fn set_o_almost_full(&mut self, val: u8) {
        self.io.set(self.ids.o_almost_full, val);
    }
    pub fn set_o_almost_full_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.io.set_four_state(self.ids.o_almost_full, val, mask);
    }
    pub fn set_i_rst(&mut self, val: u8) {
        self.io.set(self.ids.i_rst, val);
    }
    pub fn set_i_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_rst, val, mask);
    }
    pub fn set_i_clear(&mut self, val: u8) {
        self.io.set(self.ids.i_clear, val);
    }
    pub fn set_i_clear_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_clear, val, mask);
    }
    pub fn set_o_write_to_ram(&mut self, val: u8) {
        self.io.set(self.ids.o_write_to_ram, val);
    }
    pub fn set_o_write_to_ram_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.io.set_four_state(self.ids.o_write_to_ram, val, mask);
    }
    pub fn set_o_full(&mut self, val: u8) {
        self.io.set(self.ids.o_full, val);
    }
    pub fn set_o_full_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_full, val, mask);
    }
    pub fn set_o_empty(&mut self, val: u8) {
        self.io.set(self.ids.o_empty, val);
    }
    pub fn set_o_empty_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_empty, val, mask);
    }
    pub fn set_o_write_pointer(&mut self, val: u8) {
        self.io.set(self.ids.o_write_pointer, val);
    }
    pub fn set_o_write_pointer_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.io.set_four_state(self.ids.o_write_pointer, val, mask);
    }
    pub fn set_o_write_to_ff(&mut self, val: u8) {
        self.io.set(self.ids.o_write_to_ff, val);
    }
    pub fn set_o_write_to_ff_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.io.set_four_state(self.ids.o_write_to_ff, val, mask);
    }
    pub fn set_i_pop(&mut self, val: u8) {
        self.io.set(self.ids.i_pop, val);
    }
    pub fn set_i_pop_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_pop, val, mask);
    }
    pub fn set_o_read_from_ram(&mut self, val: u8) {
        self.io.set(self.ids.o_read_from_ram, val);
    }
    pub fn set_o_read_from_ram_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.io.set_four_state(self.ids.o_read_from_ram, val, mask);
    }
    pub fn set_i_data(&mut self, val: u8) {
        self.io.set(self.ids.i_data, val);
    }
    pub fn set_i_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_data, val, mask);
    }
}
pub struct gray_counter {
    pub i_clk: celox::EventRef,
    pub i_rst: celox::SignalRef,
    pub o_wrap_around: celox::SignalRef,
    pub i_clear: celox::SignalRef,
    pub i_up: celox::SignalRef,
    pub o_count_next: celox::SignalRef,
    pub o_count: celox::SignalRef,
    pub i_down: celox::SignalRef,
    pub i_set_value: celox::SignalRef,
    pub i_set: celox::SignalRef,
}
impl gray_counter {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            i_clk: sim.event("i_clk"),
            i_rst: sim.signal("i_rst"),
            o_wrap_around: sim.signal("o_wrap_around"),
            i_clear: sim.signal("i_clear"),
            i_up: sim.signal("i_up"),
            o_count_next: sim.signal("o_count_next"),
            o_count: sim.signal("o_count"),
            i_down: sim.signal("i_down"),
            i_set_value: sim.signal("i_set_value"),
            i_set: sim.signal("i_set"),
        }
    }
    pub fn set_i_rst(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_rst, val)).unwrap();
    }
    pub fn get_i_rst(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_rst);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_rst"))
    }
    pub fn set_i_rst_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_rst, val, mask)).unwrap();
    }
    pub fn get_i_rst_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_rst)
    }
    pub fn set_o_wrap_around(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_wrap_around, val)).unwrap();
    }
    pub fn get_o_wrap_around(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_wrap_around);
        val.try_into()
            .unwrap_or_else(|_| panic!("Value overflow for {}", "o_wrap_around"))
    }
    pub fn set_o_wrap_around_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_wrap_around, val, mask)).unwrap();
    }
    pub fn get_o_wrap_around_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_wrap_around)
    }
    pub fn set_i_clear(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_clear, val)).unwrap();
    }
    pub fn get_i_clear(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_clear);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_clear"))
    }
    pub fn set_i_clear_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_clear, val, mask)).unwrap();
    }
    pub fn get_i_clear_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_clear)
    }
    pub fn set_i_up(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_up, val)).unwrap();
    }
    pub fn get_i_up(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_up);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_up"))
    }
    pub fn set_i_up_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_up, val, mask)).unwrap();
    }
    pub fn get_i_up_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_up)
    }
    pub fn set_o_count_next(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_count_next, val)).unwrap();
    }
    pub fn get_o_count_next(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_count_next);
        val.try_into()
            .unwrap_or_else(|_| panic!("Value overflow for {}", "o_count_next"))
    }
    pub fn set_o_count_next_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_count_next, val, mask)).unwrap();
    }
    pub fn get_o_count_next_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_count_next)
    }
    pub fn set_o_count(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_count, val)).unwrap();
    }
    pub fn get_o_count(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_count);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_count"))
    }
    pub fn set_o_count_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_count, val, mask)).unwrap();
    }
    pub fn get_o_count_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_count)
    }
    pub fn set_i_down(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_down, val)).unwrap();
    }
    pub fn get_i_down(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_down);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_down"))
    }
    pub fn set_i_down_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_down, val, mask)).unwrap();
    }
    pub fn get_i_down_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_down)
    }
    pub fn set_i_set_value(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_set_value, val)).unwrap();
    }
    pub fn get_i_set_value(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_set_value);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_set_value"))
    }
    pub fn set_i_set_value_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_set_value, val, mask)).unwrap();
    }
    pub fn get_i_set_value_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_set_value)
    }
    pub fn set_i_set(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_set, val)).unwrap();
    }
    pub fn get_i_set(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_set);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_set"))
    }
    pub fn set_i_set_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_set, val, mask)).unwrap();
    }
    pub fn get_i_set_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_set)
    }
    pub fn bind<'a>(&'a self, sim: &'a mut celox::Simulator) -> gray_counterBound<'a> {
        gray_counterBound {
            sim,
            ids: self,
        }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {
        sim.tick(self.i_clk).unwrap();
    }
}
pub struct gray_counterBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a gray_counter,
}
impl<'a> gray_counterBound<'a> {
    pub fn set_i_rst(&mut self, val: u8) {
        self.ids.set_i_rst(self.sim, val);
    }
    pub fn get_i_rst(&mut self) -> u8 {
        self.ids.get_i_rst(self.sim)
    }
    pub fn set_i_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_rst_4state(self.sim, val, mask);
    }
    pub fn get_i_rst_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_rst_4state(self.sim)
    }
    pub fn set_o_wrap_around(&mut self, val: u8) {
        self.ids.set_o_wrap_around(self.sim, val);
    }
    pub fn get_o_wrap_around(&mut self) -> u8 {
        self.ids.get_o_wrap_around(self.sim)
    }
    pub fn set_o_wrap_around_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.ids.set_o_wrap_around_4state(self.sim, val, mask);
    }
    pub fn get_o_wrap_around_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_wrap_around_4state(self.sim)
    }
    pub fn set_i_clear(&mut self, val: u8) {
        self.ids.set_i_clear(self.sim, val);
    }
    pub fn get_i_clear(&mut self) -> u8 {
        self.ids.get_i_clear(self.sim)
    }
    pub fn set_i_clear_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_clear_4state(self.sim, val, mask);
    }
    pub fn get_i_clear_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_clear_4state(self.sim)
    }
    pub fn set_i_up(&mut self, val: u8) {
        self.ids.set_i_up(self.sim, val);
    }
    pub fn get_i_up(&mut self) -> u8 {
        self.ids.get_i_up(self.sim)
    }
    pub fn set_i_up_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_up_4state(self.sim, val, mask);
    }
    pub fn get_i_up_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_up_4state(self.sim)
    }
    pub fn set_o_count_next(&mut self, val: u8) {
        self.ids.set_o_count_next(self.sim, val);
    }
    pub fn get_o_count_next(&mut self) -> u8 {
        self.ids.get_o_count_next(self.sim)
    }
    pub fn set_o_count_next_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.ids.set_o_count_next_4state(self.sim, val, mask);
    }
    pub fn get_o_count_next_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_count_next_4state(self.sim)
    }
    pub fn set_o_count(&mut self, val: u8) {
        self.ids.set_o_count(self.sim, val);
    }
    pub fn get_o_count(&mut self) -> u8 {
        self.ids.get_o_count(self.sim)
    }
    pub fn set_o_count_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_count_4state(self.sim, val, mask);
    }
    pub fn get_o_count_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_count_4state(self.sim)
    }
    pub fn set_i_down(&mut self, val: u8) {
        self.ids.set_i_down(self.sim, val);
    }
    pub fn get_i_down(&mut self) -> u8 {
        self.ids.get_i_down(self.sim)
    }
    pub fn set_i_down_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_down_4state(self.sim, val, mask);
    }
    pub fn get_i_down_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_down_4state(self.sim)
    }
    pub fn set_i_set_value(&mut self, val: u8) {
        self.ids.set_i_set_value(self.sim, val);
    }
    pub fn get_i_set_value(&mut self) -> u8 {
        self.ids.get_i_set_value(self.sim)
    }
    pub fn set_i_set_value_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_set_value_4state(self.sim, val, mask);
    }
    pub fn get_i_set_value_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_set_value_4state(self.sim)
    }
    pub fn set_i_set(&mut self, val: u8) {
        self.ids.set_i_set(self.sim, val);
    }
    pub fn get_i_set(&mut self) -> u8 {
        self.ids.get_i_set(self.sim)
    }
    pub fn set_i_set_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_set_4state(self.sim, val, mask);
    }
    pub fn get_i_set_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_set_4state(self.sim)
    }
    pub fn tick(&mut self) {
        self.sim.tick(self.ids.i_clk).unwrap();
    }
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut gray_counterIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = gray_counterIO {
                    io,
                    ids: self.ids,
                };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct gray_counterIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a gray_counter,
}
impl<'a, 'b> gray_counterIO<'a, 'b> {
    pub fn set_i_rst(&mut self, val: u8) {
        self.io.set(self.ids.i_rst, val);
    }
    pub fn set_i_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_rst, val, mask);
    }
    pub fn set_o_wrap_around(&mut self, val: u8) {
        self.io.set(self.ids.o_wrap_around, val);
    }
    pub fn set_o_wrap_around_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.io.set_four_state(self.ids.o_wrap_around, val, mask);
    }
    pub fn set_i_clear(&mut self, val: u8) {
        self.io.set(self.ids.i_clear, val);
    }
    pub fn set_i_clear_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_clear, val, mask);
    }
    pub fn set_i_up(&mut self, val: u8) {
        self.io.set(self.ids.i_up, val);
    }
    pub fn set_i_up_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_up, val, mask);
    }
    pub fn set_o_count_next(&mut self, val: u8) {
        self.io.set(self.ids.o_count_next, val);
    }
    pub fn set_o_count_next_4state(
        &mut self,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        self.io.set_four_state(self.ids.o_count_next, val, mask);
    }
    pub fn set_o_count(&mut self, val: u8) {
        self.io.set(self.ids.o_count, val);
    }
    pub fn set_o_count_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_count, val, mask);
    }
    pub fn set_i_down(&mut self, val: u8) {
        self.io.set(self.ids.i_down, val);
    }
    pub fn set_i_down_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_down, val, mask);
    }
    pub fn set_i_set_value(&mut self, val: u8) {
        self.io.set(self.ids.i_set_value, val);
    }
    pub fn set_i_set_value_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_set_value, val, mask);
    }
    pub fn set_i_set(&mut self, val: u8) {
        self.io.set(self.ids.i_set, val);
    }
    pub fn set_i_set_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_set, val, mask);
    }
}
pub struct gray_decoder {
    pub i_gray: celox::SignalRef,
    pub o_bin: celox::SignalRef,
}
impl gray_decoder {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            i_gray: sim.signal("i_gray"),
            o_bin: sim.signal("o_bin"),
        }
    }
    pub fn set_i_gray(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_gray, val)).unwrap();
    }
    pub fn get_i_gray(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_gray);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_gray"))
    }
    pub fn set_i_gray_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_gray, val, mask)).unwrap();
    }
    pub fn get_i_gray_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_gray)
    }
    pub fn set_o_bin(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_bin, val)).unwrap();
    }
    pub fn get_o_bin(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_bin);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_bin"))
    }
    pub fn set_o_bin_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_bin, val, mask)).unwrap();
    }
    pub fn get_o_bin_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_bin)
    }
    pub fn bind<'a>(&'a self, sim: &'a mut celox::Simulator) -> gray_decoderBound<'a> {
        gray_decoderBound {
            sim,
            ids: self,
        }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {}
}
pub struct gray_decoderBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a gray_decoder,
}
impl<'a> gray_decoderBound<'a> {
    pub fn set_i_gray(&mut self, val: u8) {
        self.ids.set_i_gray(self.sim, val);
    }
    pub fn get_i_gray(&mut self) -> u8 {
        self.ids.get_i_gray(self.sim)
    }
    pub fn set_i_gray_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_gray_4state(self.sim, val, mask);
    }
    pub fn get_i_gray_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_gray_4state(self.sim)
    }
    pub fn set_o_bin(&mut self, val: u8) {
        self.ids.set_o_bin(self.sim, val);
    }
    pub fn get_o_bin(&mut self) -> u8 {
        self.ids.get_o_bin(self.sim)
    }
    pub fn set_o_bin_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_bin_4state(self.sim, val, mask);
    }
    pub fn get_o_bin_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_bin_4state(self.sim)
    }
    pub fn tick(&mut self) {}
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut gray_decoderIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = gray_decoderIO {
                    io,
                    ids: self.ids,
                };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct gray_decoderIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a gray_decoder,
}
impl<'a, 'b> gray_decoderIO<'a, 'b> {
    pub fn set_i_gray(&mut self, val: u8) {
        self.io.set(self.ids.i_gray, val);
    }
    pub fn set_i_gray_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_gray, val, mask);
    }
    pub fn set_o_bin(&mut self, val: u8) {
        self.io.set(self.ids.o_bin, val);
    }
    pub fn set_o_bin_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_bin, val, mask);
    }
}
pub struct gray_encoder {
    pub i_bin: celox::SignalRef,
    pub o_gray: celox::SignalRef,
}
impl gray_encoder {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            i_bin: sim.signal("i_bin"),
            o_gray: sim.signal("o_gray"),
        }
    }
    pub fn set_i_bin(&self, sim: &mut celox::Simulator, val: u32) {
        sim.modify(|io| io.set(self.i_bin, val)).unwrap();
    }
    pub fn get_i_bin(&self, sim: &mut celox::Simulator) -> u32 {
        let val = sim.get(self.i_bin);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_bin"))
    }
    pub fn set_i_bin_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_bin, val, mask)).unwrap();
    }
    pub fn get_i_bin_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_bin)
    }
    pub fn set_o_gray(&self, sim: &mut celox::Simulator, val: u32) {
        sim.modify(|io| io.set(self.o_gray, val)).unwrap();
    }
    pub fn get_o_gray(&self, sim: &mut celox::Simulator) -> u32 {
        let val = sim.get(self.o_gray);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_gray"))
    }
    pub fn set_o_gray_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_gray, val, mask)).unwrap();
    }
    pub fn get_o_gray_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_gray)
    }
    pub fn bind<'a>(&'a self, sim: &'a mut celox::Simulator) -> gray_encoderBound<'a> {
        gray_encoderBound {
            sim,
            ids: self,
        }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {}
}
pub struct gray_encoderBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a gray_encoder,
}
impl<'a> gray_encoderBound<'a> {
    pub fn set_i_bin(&mut self, val: u32) {
        self.ids.set_i_bin(self.sim, val);
    }
    pub fn get_i_bin(&mut self) -> u32 {
        self.ids.get_i_bin(self.sim)
    }
    pub fn set_i_bin_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_bin_4state(self.sim, val, mask);
    }
    pub fn get_i_bin_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_bin_4state(self.sim)
    }
    pub fn set_o_gray(&mut self, val: u32) {
        self.ids.set_o_gray(self.sim, val);
    }
    pub fn get_o_gray(&mut self) -> u32 {
        self.ids.get_o_gray(self.sim)
    }
    pub fn set_o_gray_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_gray_4state(self.sim, val, mask);
    }
    pub fn get_o_gray_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_gray_4state(self.sim)
    }
    pub fn tick(&mut self) {}
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut gray_encoderIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = gray_encoderIO {
                    io,
                    ids: self.ids,
                };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct gray_encoderIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a gray_encoder,
}
impl<'a, 'b> gray_encoderIO<'a, 'b> {
    pub fn set_i_bin(&mut self, val: u32) {
        self.io.set(self.ids.i_bin, val);
    }
    pub fn set_i_bin_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_bin, val, mask);
    }
    pub fn set_o_gray(&mut self, val: u32) {
        self.io.set(self.ids.o_gray, val);
    }
    pub fn set_o_gray_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_gray, val, mask);
    }
}
pub struct lfsr_galois {
    pub i_clk: celox::EventRef,
    pub i_en: celox::SignalRef,
    pub o_val: celox::SignalRef,
    pub i_setval: celox::SignalRef,
    pub i_set: celox::SignalRef,
}
impl lfsr_galois {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            i_clk: sim.event("i_clk"),
            i_en: sim.signal("i_en"),
            o_val: sim.signal("o_val"),
            i_setval: sim.signal("i_setval"),
            i_set: sim.signal("i_set"),
        }
    }
    pub fn set_i_en(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_en, val)).unwrap();
    }
    pub fn get_i_en(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_en);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_en"))
    }
    pub fn set_i_en_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_en, val, mask)).unwrap();
    }
    pub fn get_i_en_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_en)
    }
    pub fn set_o_val(&self, sim: &mut celox::Simulator, val: u64) {
        sim.modify(|io| io.set(self.o_val, val)).unwrap();
    }
    pub fn get_o_val(&self, sim: &mut celox::Simulator) -> u64 {
        let val = sim.get(self.o_val);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_val"))
    }
    pub fn set_o_val_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_val, val, mask)).unwrap();
    }
    pub fn get_o_val_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_val)
    }
    pub fn set_i_setval(&self, sim: &mut celox::Simulator, val: u64) {
        sim.modify(|io| io.set(self.i_setval, val)).unwrap();
    }
    pub fn get_i_setval(&self, sim: &mut celox::Simulator) -> u64 {
        let val = sim.get(self.i_setval);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_setval"))
    }
    pub fn set_i_setval_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_setval, val, mask)).unwrap();
    }
    pub fn get_i_setval_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_setval)
    }
    pub fn set_i_set(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_set, val)).unwrap();
    }
    pub fn get_i_set(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_set);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_set"))
    }
    pub fn set_i_set_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_set, val, mask)).unwrap();
    }
    pub fn get_i_set_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_set)
    }
    pub fn bind<'a>(&'a self, sim: &'a mut celox::Simulator) -> lfsr_galoisBound<'a> {
        lfsr_galoisBound { sim, ids: self }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {
        sim.tick(self.i_clk).unwrap();
    }
}
pub struct lfsr_galoisBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a lfsr_galois,
}
impl<'a> lfsr_galoisBound<'a> {
    pub fn set_i_en(&mut self, val: u8) {
        self.ids.set_i_en(self.sim, val);
    }
    pub fn get_i_en(&mut self) -> u8 {
        self.ids.get_i_en(self.sim)
    }
    pub fn set_i_en_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_en_4state(self.sim, val, mask);
    }
    pub fn get_i_en_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_en_4state(self.sim)
    }
    pub fn set_o_val(&mut self, val: u64) {
        self.ids.set_o_val(self.sim, val);
    }
    pub fn get_o_val(&mut self) -> u64 {
        self.ids.get_o_val(self.sim)
    }
    pub fn set_o_val_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_val_4state(self.sim, val, mask);
    }
    pub fn get_o_val_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_val_4state(self.sim)
    }
    pub fn set_i_setval(&mut self, val: u64) {
        self.ids.set_i_setval(self.sim, val);
    }
    pub fn get_i_setval(&mut self) -> u64 {
        self.ids.get_i_setval(self.sim)
    }
    pub fn set_i_setval_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_setval_4state(self.sim, val, mask);
    }
    pub fn get_i_setval_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_setval_4state(self.sim)
    }
    pub fn set_i_set(&mut self, val: u8) {
        self.ids.set_i_set(self.sim, val);
    }
    pub fn get_i_set(&mut self) -> u8 {
        self.ids.get_i_set(self.sim)
    }
    pub fn set_i_set_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_set_4state(self.sim, val, mask);
    }
    pub fn get_i_set_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_set_4state(self.sim)
    }
    pub fn tick(&mut self) {
        self.sim.tick(self.ids.i_clk).unwrap();
    }
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut lfsr_galoisIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = lfsr_galoisIO { io, ids: self.ids };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct lfsr_galoisIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a lfsr_galois,
}
impl<'a, 'b> lfsr_galoisIO<'a, 'b> {
    pub fn set_i_en(&mut self, val: u8) {
        self.io.set(self.ids.i_en, val);
    }
    pub fn set_i_en_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_en, val, mask);
    }
    pub fn set_o_val(&mut self, val: u64) {
        self.io.set(self.ids.o_val, val);
    }
    pub fn set_o_val_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_val, val, mask);
    }
    pub fn set_i_setval(&mut self, val: u64) {
        self.io.set(self.ids.i_setval, val);
    }
    pub fn set_i_setval_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_setval, val, mask);
    }
    pub fn set_i_set(&mut self, val: u8) {
        self.io.set(self.ids.i_set, val);
    }
    pub fn set_i_set_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_set, val, mask);
    }
}
pub struct ram {
    pub i_clk: celox::EventRef,
    pub i_meb: celox::SignalRef,
    pub i_wea: celox::SignalRef,
    pub i_adra: celox::SignalRef,
    pub i_rst: celox::SignalRef,
    pub i_clr: celox::SignalRef,
    pub i_adrb: celox::SignalRef,
    pub o_qb: celox::SignalRef,
    pub i_da: celox::SignalRef,
    pub i_mea: celox::SignalRef,
}
impl ram {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            i_clk: sim.event("i_clk"),
            i_meb: sim.signal("i_meb"),
            i_wea: sim.signal("i_wea"),
            i_adra: sim.signal("i_adra"),
            i_rst: sim.signal("i_rst"),
            i_clr: sim.signal("i_clr"),
            i_adrb: sim.signal("i_adrb"),
            o_qb: sim.signal("o_qb"),
            i_da: sim.signal("i_da"),
            i_mea: sim.signal("i_mea"),
        }
    }
    pub fn set_i_meb(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_meb, val)).unwrap();
    }
    pub fn get_i_meb(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_meb);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_meb"))
    }
    pub fn set_i_meb_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_meb, val, mask)).unwrap();
    }
    pub fn get_i_meb_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_meb)
    }
    pub fn set_i_wea(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_wea, val)).unwrap();
    }
    pub fn get_i_wea(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_wea);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_wea"))
    }
    pub fn set_i_wea_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_wea, val, mask)).unwrap();
    }
    pub fn get_i_wea_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_wea)
    }
    pub fn set_i_adra(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_adra, val)).unwrap();
    }
    pub fn get_i_adra(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_adra);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_adra"))
    }
    pub fn set_i_adra_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_adra, val, mask)).unwrap();
    }
    pub fn get_i_adra_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_adra)
    }
    pub fn set_i_rst(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_rst, val)).unwrap();
    }
    pub fn get_i_rst(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_rst);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_rst"))
    }
    pub fn set_i_rst_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_rst, val, mask)).unwrap();
    }
    pub fn get_i_rst_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_rst)
    }
    pub fn set_i_clr(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_clr, val)).unwrap();
    }
    pub fn get_i_clr(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_clr);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_clr"))
    }
    pub fn set_i_clr_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_clr, val, mask)).unwrap();
    }
    pub fn get_i_clr_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_clr)
    }
    pub fn set_i_adrb(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_adrb, val)).unwrap();
    }
    pub fn get_i_adrb(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_adrb);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_adrb"))
    }
    pub fn set_i_adrb_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_adrb, val, mask)).unwrap();
    }
    pub fn get_i_adrb_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_adrb)
    }
    pub fn set_o_qb(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_qb, val)).unwrap();
    }
    pub fn get_o_qb(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_qb);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_qb"))
    }
    pub fn set_o_qb_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_qb, val, mask)).unwrap();
    }
    pub fn get_o_qb_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_qb)
    }
    pub fn set_i_da(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_da, val)).unwrap();
    }
    pub fn get_i_da(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_da);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_da"))
    }
    pub fn set_i_da_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_da, val, mask)).unwrap();
    }
    pub fn get_i_da_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_da)
    }
    pub fn set_i_mea(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_mea, val)).unwrap();
    }
    pub fn get_i_mea(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_mea);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_mea"))
    }
    pub fn set_i_mea_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_mea, val, mask)).unwrap();
    }
    pub fn get_i_mea_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_mea)
    }
    pub fn bind<'a>(&'a self, sim: &'a mut celox::Simulator) -> ramBound<'a> {
        ramBound { sim, ids: self }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {
        sim.tick(self.i_clk).unwrap();
    }
}
pub struct ramBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a ram,
}
impl<'a> ramBound<'a> {
    pub fn set_i_meb(&mut self, val: u8) {
        self.ids.set_i_meb(self.sim, val);
    }
    pub fn get_i_meb(&mut self) -> u8 {
        self.ids.get_i_meb(self.sim)
    }
    pub fn set_i_meb_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_meb_4state(self.sim, val, mask);
    }
    pub fn get_i_meb_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_meb_4state(self.sim)
    }
    pub fn set_i_wea(&mut self, val: u8) {
        self.ids.set_i_wea(self.sim, val);
    }
    pub fn get_i_wea(&mut self) -> u8 {
        self.ids.get_i_wea(self.sim)
    }
    pub fn set_i_wea_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_wea_4state(self.sim, val, mask);
    }
    pub fn get_i_wea_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_wea_4state(self.sim)
    }
    pub fn set_i_adra(&mut self, val: u8) {
        self.ids.set_i_adra(self.sim, val);
    }
    pub fn get_i_adra(&mut self) -> u8 {
        self.ids.get_i_adra(self.sim)
    }
    pub fn set_i_adra_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_adra_4state(self.sim, val, mask);
    }
    pub fn get_i_adra_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_adra_4state(self.sim)
    }
    pub fn set_i_rst(&mut self, val: u8) {
        self.ids.set_i_rst(self.sim, val);
    }
    pub fn get_i_rst(&mut self) -> u8 {
        self.ids.get_i_rst(self.sim)
    }
    pub fn set_i_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_rst_4state(self.sim, val, mask);
    }
    pub fn get_i_rst_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_rst_4state(self.sim)
    }
    pub fn set_i_clr(&mut self, val: u8) {
        self.ids.set_i_clr(self.sim, val);
    }
    pub fn get_i_clr(&mut self) -> u8 {
        self.ids.get_i_clr(self.sim)
    }
    pub fn set_i_clr_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_clr_4state(self.sim, val, mask);
    }
    pub fn get_i_clr_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_clr_4state(self.sim)
    }
    pub fn set_i_adrb(&mut self, val: u8) {
        self.ids.set_i_adrb(self.sim, val);
    }
    pub fn get_i_adrb(&mut self) -> u8 {
        self.ids.get_i_adrb(self.sim)
    }
    pub fn set_i_adrb_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_adrb_4state(self.sim, val, mask);
    }
    pub fn get_i_adrb_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_adrb_4state(self.sim)
    }
    pub fn set_o_qb(&mut self, val: u8) {
        self.ids.set_o_qb(self.sim, val);
    }
    pub fn get_o_qb(&mut self) -> u8 {
        self.ids.get_o_qb(self.sim)
    }
    pub fn set_o_qb_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_qb_4state(self.sim, val, mask);
    }
    pub fn get_o_qb_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_qb_4state(self.sim)
    }
    pub fn set_i_da(&mut self, val: u8) {
        self.ids.set_i_da(self.sim, val);
    }
    pub fn get_i_da(&mut self) -> u8 {
        self.ids.get_i_da(self.sim)
    }
    pub fn set_i_da_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_da_4state(self.sim, val, mask);
    }
    pub fn get_i_da_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_da_4state(self.sim)
    }
    pub fn set_i_mea(&mut self, val: u8) {
        self.ids.set_i_mea(self.sim, val);
    }
    pub fn get_i_mea(&mut self) -> u8 {
        self.ids.get_i_mea(self.sim)
    }
    pub fn set_i_mea_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_mea_4state(self.sim, val, mask);
    }
    pub fn get_i_mea_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_mea_4state(self.sim)
    }
    pub fn tick(&mut self) {
        self.sim.tick(self.ids.i_clk).unwrap();
    }
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut ramIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = ramIO { io, ids: self.ids };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct ramIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a ram,
}
impl<'a, 'b> ramIO<'a, 'b> {
    pub fn set_i_meb(&mut self, val: u8) {
        self.io.set(self.ids.i_meb, val);
    }
    pub fn set_i_meb_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_meb, val, mask);
    }
    pub fn set_i_wea(&mut self, val: u8) {
        self.io.set(self.ids.i_wea, val);
    }
    pub fn set_i_wea_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_wea, val, mask);
    }
    pub fn set_i_adra(&mut self, val: u8) {
        self.io.set(self.ids.i_adra, val);
    }
    pub fn set_i_adra_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_adra, val, mask);
    }
    pub fn set_i_rst(&mut self, val: u8) {
        self.io.set(self.ids.i_rst, val);
    }
    pub fn set_i_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_rst, val, mask);
    }
    pub fn set_i_clr(&mut self, val: u8) {
        self.io.set(self.ids.i_clr, val);
    }
    pub fn set_i_clr_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_clr, val, mask);
    }
    pub fn set_i_adrb(&mut self, val: u8) {
        self.io.set(self.ids.i_adrb, val);
    }
    pub fn set_i_adrb_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_adrb, val, mask);
    }
    pub fn set_o_qb(&mut self, val: u8) {
        self.io.set(self.ids.o_qb, val);
    }
    pub fn set_o_qb_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_qb, val, mask);
    }
    pub fn set_i_da(&mut self, val: u8) {
        self.io.set(self.ids.i_da, val);
    }
    pub fn set_i_da_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_da, val, mask);
    }
    pub fn set_i_mea(&mut self, val: u8) {
        self.io.set(self.ids.i_mea, val);
    }
    pub fn set_i_mea_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_mea, val, mask);
    }
}
pub struct demux {
    pub i_select: celox::SignalRef,
    pub i_data: celox::SignalRef,
    pub o_data: celox::SignalRef,
}
impl demux {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            i_select: sim.signal("i_select"),
            i_data: sim.signal("i_data"),
            o_data: sim.signal("o_data"),
        }
    }
    pub fn set_i_select(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_select, val)).unwrap();
    }
    pub fn get_i_select(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_select);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_select"))
    }
    pub fn set_i_select_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_select, val, mask)).unwrap();
    }
    pub fn get_i_select_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_select)
    }
    pub fn set_i_data(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_data, val)).unwrap();
    }
    pub fn get_i_data(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_data);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_data"))
    }
    pub fn set_i_data_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_data, val, mask)).unwrap();
    }
    pub fn get_i_data_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_data)
    }
    pub fn set_o_data(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_data, val)).unwrap();
    }
    pub fn get_o_data(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_data);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_data"))
    }
    pub fn set_o_data_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_data, val, mask)).unwrap();
    }
    pub fn get_o_data_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_data)
    }
    pub fn bind<'a>(&'a self, sim: &'a mut celox::Simulator) -> demuxBound<'a> {
        demuxBound { sim, ids: self }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {}
}
pub struct demuxBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a demux,
}
impl<'a> demuxBound<'a> {
    pub fn set_i_select(&mut self, val: u8) {
        self.ids.set_i_select(self.sim, val);
    }
    pub fn get_i_select(&mut self) -> u8 {
        self.ids.get_i_select(self.sim)
    }
    pub fn set_i_select_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_select_4state(self.sim, val, mask);
    }
    pub fn get_i_select_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_select_4state(self.sim)
    }
    pub fn set_i_data(&mut self, val: u8) {
        self.ids.set_i_data(self.sim, val);
    }
    pub fn get_i_data(&mut self) -> u8 {
        self.ids.get_i_data(self.sim)
    }
    pub fn set_i_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_data_4state(self.sim, val, mask);
    }
    pub fn get_i_data_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_data_4state(self.sim)
    }
    pub fn set_o_data(&mut self, val: u8) {
        self.ids.set_o_data(self.sim, val);
    }
    pub fn get_o_data(&mut self) -> u8 {
        self.ids.get_o_data(self.sim)
    }
    pub fn set_o_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_data_4state(self.sim, val, mask);
    }
    pub fn get_o_data_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_data_4state(self.sim)
    }
    pub fn tick(&mut self) {}
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut demuxIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = demuxIO { io, ids: self.ids };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct demuxIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a demux,
}
impl<'a, 'b> demuxIO<'a, 'b> {
    pub fn set_i_select(&mut self, val: u8) {
        self.io.set(self.ids.i_select, val);
    }
    pub fn set_i_select_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_select, val, mask);
    }
    pub fn set_i_data(&mut self, val: u8) {
        self.io.set(self.ids.i_data, val);
    }
    pub fn set_i_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_data, val, mask);
    }
    pub fn set_o_data(&mut self, val: u8) {
        self.io.set(self.ids.o_data, val);
    }
    pub fn set_o_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_data, val, mask);
    }
}
pub struct mux {
    pub o_data: celox::SignalRef,
    pub i_select: celox::SignalRef,
    pub i_data: celox::SignalRef,
}
impl mux {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            o_data: sim.signal("o_data"),
            i_select: sim.signal("i_select"),
            i_data: sim.signal("i_data"),
        }
    }
    pub fn set_o_data(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_data, val)).unwrap();
    }
    pub fn get_o_data(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_data);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_data"))
    }
    pub fn set_o_data_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_data, val, mask)).unwrap();
    }
    pub fn get_o_data_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_data)
    }
    pub fn set_i_select(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_select, val)).unwrap();
    }
    pub fn get_i_select(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_select);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_select"))
    }
    pub fn set_i_select_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_select, val, mask)).unwrap();
    }
    pub fn get_i_select_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_select)
    }
    pub fn set_i_data(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_data, val)).unwrap();
    }
    pub fn get_i_data(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_data);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_data"))
    }
    pub fn set_i_data_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_data, val, mask)).unwrap();
    }
    pub fn get_i_data_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_data)
    }
    pub fn bind<'a>(&'a self, sim: &'a mut celox::Simulator) -> muxBound<'a> {
        muxBound { sim, ids: self }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {}
}
pub struct muxBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a mux,
}
impl<'a> muxBound<'a> {
    pub fn set_o_data(&mut self, val: u8) {
        self.ids.set_o_data(self.sim, val);
    }
    pub fn get_o_data(&mut self) -> u8 {
        self.ids.get_o_data(self.sim)
    }
    pub fn set_o_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_data_4state(self.sim, val, mask);
    }
    pub fn get_o_data_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_data_4state(self.sim)
    }
    pub fn set_i_select(&mut self, val: u8) {
        self.ids.set_i_select(self.sim, val);
    }
    pub fn get_i_select(&mut self) -> u8 {
        self.ids.get_i_select(self.sim)
    }
    pub fn set_i_select_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_select_4state(self.sim, val, mask);
    }
    pub fn get_i_select_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_select_4state(self.sim)
    }
    pub fn set_i_data(&mut self, val: u8) {
        self.ids.set_i_data(self.sim, val);
    }
    pub fn get_i_data(&mut self) -> u8 {
        self.ids.get_i_data(self.sim)
    }
    pub fn set_i_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_data_4state(self.sim, val, mask);
    }
    pub fn get_i_data_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_data_4state(self.sim)
    }
    pub fn tick(&mut self) {}
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut muxIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = muxIO { io, ids: self.ids };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct muxIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a mux,
}
impl<'a, 'b> muxIO<'a, 'b> {
    pub fn set_o_data(&mut self, val: u8) {
        self.io.set(self.ids.o_data, val);
    }
    pub fn set_o_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_data, val, mask);
    }
    pub fn set_i_select(&mut self, val: u8) {
        self.io.set(self.ids.i_select, val);
    }
    pub fn set_i_select_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_select, val, mask);
    }
    pub fn set_i_data(&mut self, val: u8) {
        self.io.set(self.ids.i_data, val);
    }
    pub fn set_i_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_data, val, mask);
    }
}
pub struct slicer {
    pub i_clk: celox::EventRef,
    pub o_data: celox::SignalRef,
    pub i_rst: celox::SignalRef,
    pub i_valid: celox::SignalRef,
    pub i_ready: celox::SignalRef,
    pub i_data: celox::SignalRef,
    pub o_valid: celox::SignalRef,
    pub o_ready: celox::SignalRef,
}
impl slicer {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            i_clk: sim.event("i_clk"),
            o_data: sim.signal("o_data"),
            i_rst: sim.signal("i_rst"),
            i_valid: sim.signal("i_valid"),
            i_ready: sim.signal("i_ready"),
            i_data: sim.signal("i_data"),
            o_valid: sim.signal("o_valid"),
            o_ready: sim.signal("o_ready"),
        }
    }
    pub fn set_o_data(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_data, val)).unwrap();
    }
    pub fn get_o_data(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_data);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_data"))
    }
    pub fn set_o_data_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_data, val, mask)).unwrap();
    }
    pub fn get_o_data_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_data)
    }
    pub fn set_i_rst(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_rst, val)).unwrap();
    }
    pub fn get_i_rst(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_rst);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_rst"))
    }
    pub fn set_i_rst_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_rst, val, mask)).unwrap();
    }
    pub fn get_i_rst_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_rst)
    }
    pub fn set_i_valid(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_valid, val)).unwrap();
    }
    pub fn get_i_valid(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_valid);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_valid"))
    }
    pub fn set_i_valid_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_valid, val, mask)).unwrap();
    }
    pub fn get_i_valid_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_valid)
    }
    pub fn set_i_ready(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_ready, val)).unwrap();
    }
    pub fn get_i_ready(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_ready);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_ready"))
    }
    pub fn set_i_ready_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_ready, val, mask)).unwrap();
    }
    pub fn get_i_ready_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_ready)
    }
    pub fn set_i_data(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_data, val)).unwrap();
    }
    pub fn get_i_data(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_data);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_data"))
    }
    pub fn set_i_data_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_data, val, mask)).unwrap();
    }
    pub fn get_i_data_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_data)
    }
    pub fn set_o_valid(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_valid, val)).unwrap();
    }
    pub fn get_o_valid(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_valid);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_valid"))
    }
    pub fn set_o_valid_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_valid, val, mask)).unwrap();
    }
    pub fn get_o_valid_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_valid)
    }
    pub fn set_o_ready(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_ready, val)).unwrap();
    }
    pub fn get_o_ready(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_ready);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_ready"))
    }
    pub fn set_o_ready_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_ready, val, mask)).unwrap();
    }
    pub fn get_o_ready_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_ready)
    }
    pub fn bind<'a>(&'a self, sim: &'a mut celox::Simulator) -> slicerBound<'a> {
        slicerBound { sim, ids: self }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {
        sim.tick(self.i_clk).unwrap();
    }
}
pub struct slicerBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a slicer,
}
impl<'a> slicerBound<'a> {
    pub fn set_o_data(&mut self, val: u8) {
        self.ids.set_o_data(self.sim, val);
    }
    pub fn get_o_data(&mut self) -> u8 {
        self.ids.get_o_data(self.sim)
    }
    pub fn set_o_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_data_4state(self.sim, val, mask);
    }
    pub fn get_o_data_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_data_4state(self.sim)
    }
    pub fn set_i_rst(&mut self, val: u8) {
        self.ids.set_i_rst(self.sim, val);
    }
    pub fn get_i_rst(&mut self) -> u8 {
        self.ids.get_i_rst(self.sim)
    }
    pub fn set_i_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_rst_4state(self.sim, val, mask);
    }
    pub fn get_i_rst_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_rst_4state(self.sim)
    }
    pub fn set_i_valid(&mut self, val: u8) {
        self.ids.set_i_valid(self.sim, val);
    }
    pub fn get_i_valid(&mut self) -> u8 {
        self.ids.get_i_valid(self.sim)
    }
    pub fn set_i_valid_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_valid_4state(self.sim, val, mask);
    }
    pub fn get_i_valid_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_valid_4state(self.sim)
    }
    pub fn set_i_ready(&mut self, val: u8) {
        self.ids.set_i_ready(self.sim, val);
    }
    pub fn get_i_ready(&mut self) -> u8 {
        self.ids.get_i_ready(self.sim)
    }
    pub fn set_i_ready_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_ready_4state(self.sim, val, mask);
    }
    pub fn get_i_ready_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_ready_4state(self.sim)
    }
    pub fn set_i_data(&mut self, val: u8) {
        self.ids.set_i_data(self.sim, val);
    }
    pub fn get_i_data(&mut self) -> u8 {
        self.ids.get_i_data(self.sim)
    }
    pub fn set_i_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_data_4state(self.sim, val, mask);
    }
    pub fn get_i_data_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_data_4state(self.sim)
    }
    pub fn set_o_valid(&mut self, val: u8) {
        self.ids.set_o_valid(self.sim, val);
    }
    pub fn get_o_valid(&mut self) -> u8 {
        self.ids.get_o_valid(self.sim)
    }
    pub fn set_o_valid_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_valid_4state(self.sim, val, mask);
    }
    pub fn get_o_valid_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_valid_4state(self.sim)
    }
    pub fn set_o_ready(&mut self, val: u8) {
        self.ids.set_o_ready(self.sim, val);
    }
    pub fn get_o_ready(&mut self) -> u8 {
        self.ids.get_o_ready(self.sim)
    }
    pub fn set_o_ready_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_ready_4state(self.sim, val, mask);
    }
    pub fn get_o_ready_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_ready_4state(self.sim)
    }
    pub fn tick(&mut self) {
        self.sim.tick(self.ids.i_clk).unwrap();
    }
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut slicerIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = slicerIO { io, ids: self.ids };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct slicerIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a slicer,
}
impl<'a, 'b> slicerIO<'a, 'b> {
    pub fn set_o_data(&mut self, val: u8) {
        self.io.set(self.ids.o_data, val);
    }
    pub fn set_o_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_data, val, mask);
    }
    pub fn set_i_rst(&mut self, val: u8) {
        self.io.set(self.ids.i_rst, val);
    }
    pub fn set_i_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_rst, val, mask);
    }
    pub fn set_i_valid(&mut self, val: u8) {
        self.io.set(self.ids.i_valid, val);
    }
    pub fn set_i_valid_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_valid, val, mask);
    }
    pub fn set_i_ready(&mut self, val: u8) {
        self.io.set(self.ids.i_ready, val);
    }
    pub fn set_i_ready_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_ready, val, mask);
    }
    pub fn set_i_data(&mut self, val: u8) {
        self.io.set(self.ids.i_data, val);
    }
    pub fn set_i_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_data, val, mask);
    }
    pub fn set_o_valid(&mut self, val: u8) {
        self.io.set(self.ids.o_valid, val);
    }
    pub fn set_o_valid_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_valid, val, mask);
    }
    pub fn set_o_ready(&mut self, val: u8) {
        self.io.set(self.ids.o_ready, val);
    }
    pub fn set_o_ready_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_ready, val, mask);
    }
}
pub struct slicer_unit_fb {
    pub i_clk: celox::EventRef,
    pub o_data: celox::SignalRef,
    pub i_rst: celox::SignalRef,
    pub i_valid: celox::SignalRef,
    pub i_ready: celox::SignalRef,
    pub o_valid: celox::SignalRef,
    pub o_ready: celox::SignalRef,
    pub i_data: celox::SignalRef,
}
impl slicer_unit_fb {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            i_clk: sim.event("i_clk"),
            o_data: sim.signal("o_data"),
            i_rst: sim.signal("i_rst"),
            i_valid: sim.signal("i_valid"),
            i_ready: sim.signal("i_ready"),
            o_valid: sim.signal("o_valid"),
            o_ready: sim.signal("o_ready"),
            i_data: sim.signal("i_data"),
        }
    }
    pub fn set_o_data(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_data, val)).unwrap();
    }
    pub fn get_o_data(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_data);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_data"))
    }
    pub fn set_o_data_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_data, val, mask)).unwrap();
    }
    pub fn get_o_data_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_data)
    }
    pub fn set_i_rst(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_rst, val)).unwrap();
    }
    pub fn get_i_rst(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_rst);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_rst"))
    }
    pub fn set_i_rst_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_rst, val, mask)).unwrap();
    }
    pub fn get_i_rst_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_rst)
    }
    pub fn set_i_valid(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_valid, val)).unwrap();
    }
    pub fn get_i_valid(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_valid);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_valid"))
    }
    pub fn set_i_valid_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_valid, val, mask)).unwrap();
    }
    pub fn get_i_valid_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_valid)
    }
    pub fn set_i_ready(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_ready, val)).unwrap();
    }
    pub fn get_i_ready(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_ready);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_ready"))
    }
    pub fn set_i_ready_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_ready, val, mask)).unwrap();
    }
    pub fn get_i_ready_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_ready)
    }
    pub fn set_o_valid(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_valid, val)).unwrap();
    }
    pub fn get_o_valid(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_valid);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_valid"))
    }
    pub fn set_o_valid_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_valid, val, mask)).unwrap();
    }
    pub fn get_o_valid_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_valid)
    }
    pub fn set_o_ready(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_ready, val)).unwrap();
    }
    pub fn get_o_ready(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_ready);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_ready"))
    }
    pub fn set_o_ready_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_ready, val, mask)).unwrap();
    }
    pub fn get_o_ready_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_ready)
    }
    pub fn set_i_data(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_data, val)).unwrap();
    }
    pub fn get_i_data(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_data);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_data"))
    }
    pub fn set_i_data_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_data, val, mask)).unwrap();
    }
    pub fn get_i_data_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_data)
    }
    pub fn bind<'a>(&'a self, sim: &'a mut celox::Simulator) -> slicer_unit_fbBound<'a> {
        slicer_unit_fbBound {
            sim,
            ids: self,
        }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {
        sim.tick(self.i_clk).unwrap();
    }
}
pub struct slicer_unit_fbBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a slicer_unit_fb,
}
impl<'a> slicer_unit_fbBound<'a> {
    pub fn set_o_data(&mut self, val: u8) {
        self.ids.set_o_data(self.sim, val);
    }
    pub fn get_o_data(&mut self) -> u8 {
        self.ids.get_o_data(self.sim)
    }
    pub fn set_o_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_data_4state(self.sim, val, mask);
    }
    pub fn get_o_data_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_data_4state(self.sim)
    }
    pub fn set_i_rst(&mut self, val: u8) {
        self.ids.set_i_rst(self.sim, val);
    }
    pub fn get_i_rst(&mut self) -> u8 {
        self.ids.get_i_rst(self.sim)
    }
    pub fn set_i_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_rst_4state(self.sim, val, mask);
    }
    pub fn get_i_rst_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_rst_4state(self.sim)
    }
    pub fn set_i_valid(&mut self, val: u8) {
        self.ids.set_i_valid(self.sim, val);
    }
    pub fn get_i_valid(&mut self) -> u8 {
        self.ids.get_i_valid(self.sim)
    }
    pub fn set_i_valid_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_valid_4state(self.sim, val, mask);
    }
    pub fn get_i_valid_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_valid_4state(self.sim)
    }
    pub fn set_i_ready(&mut self, val: u8) {
        self.ids.set_i_ready(self.sim, val);
    }
    pub fn get_i_ready(&mut self) -> u8 {
        self.ids.get_i_ready(self.sim)
    }
    pub fn set_i_ready_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_ready_4state(self.sim, val, mask);
    }
    pub fn get_i_ready_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_ready_4state(self.sim)
    }
    pub fn set_o_valid(&mut self, val: u8) {
        self.ids.set_o_valid(self.sim, val);
    }
    pub fn get_o_valid(&mut self) -> u8 {
        self.ids.get_o_valid(self.sim)
    }
    pub fn set_o_valid_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_valid_4state(self.sim, val, mask);
    }
    pub fn get_o_valid_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_valid_4state(self.sim)
    }
    pub fn set_o_ready(&mut self, val: u8) {
        self.ids.set_o_ready(self.sim, val);
    }
    pub fn get_o_ready(&mut self) -> u8 {
        self.ids.get_o_ready(self.sim)
    }
    pub fn set_o_ready_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_ready_4state(self.sim, val, mask);
    }
    pub fn get_o_ready_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_ready_4state(self.sim)
    }
    pub fn set_i_data(&mut self, val: u8) {
        self.ids.set_i_data(self.sim, val);
    }
    pub fn get_i_data(&mut self) -> u8 {
        self.ids.get_i_data(self.sim)
    }
    pub fn set_i_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_data_4state(self.sim, val, mask);
    }
    pub fn get_i_data_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_data_4state(self.sim)
    }
    pub fn tick(&mut self) {
        self.sim.tick(self.ids.i_clk).unwrap();
    }
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut slicer_unit_fbIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = slicer_unit_fbIO {
                    io,
                    ids: self.ids,
                };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct slicer_unit_fbIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a slicer_unit_fb,
}
impl<'a, 'b> slicer_unit_fbIO<'a, 'b> {
    pub fn set_o_data(&mut self, val: u8) {
        self.io.set(self.ids.o_data, val);
    }
    pub fn set_o_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_data, val, mask);
    }
    pub fn set_i_rst(&mut self, val: u8) {
        self.io.set(self.ids.i_rst, val);
    }
    pub fn set_i_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_rst, val, mask);
    }
    pub fn set_i_valid(&mut self, val: u8) {
        self.io.set(self.ids.i_valid, val);
    }
    pub fn set_i_valid_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_valid, val, mask);
    }
    pub fn set_i_ready(&mut self, val: u8) {
        self.io.set(self.ids.i_ready, val);
    }
    pub fn set_i_ready_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_ready, val, mask);
    }
    pub fn set_o_valid(&mut self, val: u8) {
        self.io.set(self.ids.o_valid, val);
    }
    pub fn set_o_valid_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_valid, val, mask);
    }
    pub fn set_o_ready(&mut self, val: u8) {
        self.io.set(self.ids.o_ready, val);
    }
    pub fn set_o_ready_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_ready, val, mask);
    }
    pub fn set_i_data(&mut self, val: u8) {
        self.io.set(self.ids.i_data, val);
    }
    pub fn set_i_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_data, val, mask);
    }
}
pub struct slicer_unit_hb {
    pub i_clk: celox::EventRef,
    pub o_data: celox::SignalRef,
    pub i_rst: celox::SignalRef,
    pub i_valid: celox::SignalRef,
    pub i_ready: celox::SignalRef,
    pub o_valid: celox::SignalRef,
    pub i_data: celox::SignalRef,
    pub o_ready: celox::SignalRef,
}
impl slicer_unit_hb {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            i_clk: sim.event("i_clk"),
            o_data: sim.signal("o_data"),
            i_rst: sim.signal("i_rst"),
            i_valid: sim.signal("i_valid"),
            i_ready: sim.signal("i_ready"),
            o_valid: sim.signal("o_valid"),
            i_data: sim.signal("i_data"),
            o_ready: sim.signal("o_ready"),
        }
    }
    pub fn set_o_data(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_data, val)).unwrap();
    }
    pub fn get_o_data(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_data);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_data"))
    }
    pub fn set_o_data_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_data, val, mask)).unwrap();
    }
    pub fn get_o_data_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_data)
    }
    pub fn set_i_rst(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_rst, val)).unwrap();
    }
    pub fn get_i_rst(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_rst);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_rst"))
    }
    pub fn set_i_rst_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_rst, val, mask)).unwrap();
    }
    pub fn get_i_rst_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_rst)
    }
    pub fn set_i_valid(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_valid, val)).unwrap();
    }
    pub fn get_i_valid(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_valid);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_valid"))
    }
    pub fn set_i_valid_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_valid, val, mask)).unwrap();
    }
    pub fn get_i_valid_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_valid)
    }
    pub fn set_i_ready(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_ready, val)).unwrap();
    }
    pub fn get_i_ready(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_ready);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_ready"))
    }
    pub fn set_i_ready_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_ready, val, mask)).unwrap();
    }
    pub fn get_i_ready_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_ready)
    }
    pub fn set_o_valid(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_valid, val)).unwrap();
    }
    pub fn get_o_valid(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_valid);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_valid"))
    }
    pub fn set_o_valid_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_valid, val, mask)).unwrap();
    }
    pub fn get_o_valid_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_valid)
    }
    pub fn set_i_data(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_data, val)).unwrap();
    }
    pub fn get_i_data(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_data);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_data"))
    }
    pub fn set_i_data_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_data, val, mask)).unwrap();
    }
    pub fn get_i_data_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_data)
    }
    pub fn set_o_ready(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_ready, val)).unwrap();
    }
    pub fn get_o_ready(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_ready);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_ready"))
    }
    pub fn set_o_ready_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_ready, val, mask)).unwrap();
    }
    pub fn get_o_ready_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_ready)
    }
    pub fn bind<'a>(&'a self, sim: &'a mut celox::Simulator) -> slicer_unit_hbBound<'a> {
        slicer_unit_hbBound {
            sim,
            ids: self,
        }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {
        sim.tick(self.i_clk).unwrap();
    }
}
pub struct slicer_unit_hbBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a slicer_unit_hb,
}
impl<'a> slicer_unit_hbBound<'a> {
    pub fn set_o_data(&mut self, val: u8) {
        self.ids.set_o_data(self.sim, val);
    }
    pub fn get_o_data(&mut self) -> u8 {
        self.ids.get_o_data(self.sim)
    }
    pub fn set_o_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_data_4state(self.sim, val, mask);
    }
    pub fn get_o_data_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_data_4state(self.sim)
    }
    pub fn set_i_rst(&mut self, val: u8) {
        self.ids.set_i_rst(self.sim, val);
    }
    pub fn get_i_rst(&mut self) -> u8 {
        self.ids.get_i_rst(self.sim)
    }
    pub fn set_i_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_rst_4state(self.sim, val, mask);
    }
    pub fn get_i_rst_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_rst_4state(self.sim)
    }
    pub fn set_i_valid(&mut self, val: u8) {
        self.ids.set_i_valid(self.sim, val);
    }
    pub fn get_i_valid(&mut self) -> u8 {
        self.ids.get_i_valid(self.sim)
    }
    pub fn set_i_valid_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_valid_4state(self.sim, val, mask);
    }
    pub fn get_i_valid_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_valid_4state(self.sim)
    }
    pub fn set_i_ready(&mut self, val: u8) {
        self.ids.set_i_ready(self.sim, val);
    }
    pub fn get_i_ready(&mut self) -> u8 {
        self.ids.get_i_ready(self.sim)
    }
    pub fn set_i_ready_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_ready_4state(self.sim, val, mask);
    }
    pub fn get_i_ready_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_ready_4state(self.sim)
    }
    pub fn set_o_valid(&mut self, val: u8) {
        self.ids.set_o_valid(self.sim, val);
    }
    pub fn get_o_valid(&mut self) -> u8 {
        self.ids.get_o_valid(self.sim)
    }
    pub fn set_o_valid_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_valid_4state(self.sim, val, mask);
    }
    pub fn get_o_valid_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_valid_4state(self.sim)
    }
    pub fn set_i_data(&mut self, val: u8) {
        self.ids.set_i_data(self.sim, val);
    }
    pub fn get_i_data(&mut self) -> u8 {
        self.ids.get_i_data(self.sim)
    }
    pub fn set_i_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_data_4state(self.sim, val, mask);
    }
    pub fn get_i_data_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_data_4state(self.sim)
    }
    pub fn set_o_ready(&mut self, val: u8) {
        self.ids.set_o_ready(self.sim, val);
    }
    pub fn get_o_ready(&mut self) -> u8 {
        self.ids.get_o_ready(self.sim)
    }
    pub fn set_o_ready_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_ready_4state(self.sim, val, mask);
    }
    pub fn get_o_ready_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_ready_4state(self.sim)
    }
    pub fn tick(&mut self) {
        self.sim.tick(self.ids.i_clk).unwrap();
    }
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut slicer_unit_hbIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = slicer_unit_hbIO {
                    io,
                    ids: self.ids,
                };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct slicer_unit_hbIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a slicer_unit_hb,
}
impl<'a, 'b> slicer_unit_hbIO<'a, 'b> {
    pub fn set_o_data(&mut self, val: u8) {
        self.io.set(self.ids.o_data, val);
    }
    pub fn set_o_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_data, val, mask);
    }
    pub fn set_i_rst(&mut self, val: u8) {
        self.io.set(self.ids.i_rst, val);
    }
    pub fn set_i_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_rst, val, mask);
    }
    pub fn set_i_valid(&mut self, val: u8) {
        self.io.set(self.ids.i_valid, val);
    }
    pub fn set_i_valid_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_valid, val, mask);
    }
    pub fn set_i_ready(&mut self, val: u8) {
        self.io.set(self.ids.i_ready, val);
    }
    pub fn set_i_ready_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_ready, val, mask);
    }
    pub fn set_o_valid(&mut self, val: u8) {
        self.io.set(self.ids.o_valid, val);
    }
    pub fn set_o_valid_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_valid, val, mask);
    }
    pub fn set_i_data(&mut self, val: u8) {
        self.io.set(self.ids.i_data, val);
    }
    pub fn set_i_data_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_data, val, mask);
    }
    pub fn set_o_ready(&mut self, val: u8) {
        self.io.set(self.ids.o_ready, val);
    }
    pub fn set_o_ready_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_ready, val, mask);
    }
}
pub struct synchronizer_basic {
    pub i_clk: celox::EventRef,
    pub o_d: celox::SignalRef,
    pub i_rst: celox::SignalRef,
    pub i_d: celox::SignalRef,
}
impl synchronizer_basic {
    pub fn new(sim: &celox::Simulator) -> Self {
        Self {
            i_clk: sim.event("i_clk"),
            o_d: sim.signal("o_d"),
            i_rst: sim.signal("i_rst"),
            i_d: sim.signal("i_d"),
        }
    }
    pub fn set_o_d(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.o_d, val)).unwrap();
    }
    pub fn get_o_d(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.o_d);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "o_d"))
    }
    pub fn set_o_d_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.o_d, val, mask)).unwrap();
    }
    pub fn get_o_d_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.o_d)
    }
    pub fn set_i_rst(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_rst, val)).unwrap();
    }
    pub fn get_i_rst(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_rst);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_rst"))
    }
    pub fn set_i_rst_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_rst, val, mask)).unwrap();
    }
    pub fn get_i_rst_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_rst)
    }
    pub fn set_i_d(&self, sim: &mut celox::Simulator, val: u8) {
        sim.modify(|io| io.set(self.i_d, val)).unwrap();
    }
    pub fn get_i_d(&self, sim: &mut celox::Simulator) -> u8 {
        let val = sim.get(self.i_d);
        val.try_into().unwrap_or_else(|_| panic!("Value overflow for {}", "i_d"))
    }
    pub fn set_i_d_4state(
        &self,
        sim: &mut celox::Simulator,
        val: celox::BigUint,
        mask: celox::BigUint,
    ) {
        sim.modify(|io| io.set_four_state(self.i_d, val, mask)).unwrap();
    }
    pub fn get_i_d_4state(
        &self,
        sim: &mut celox::Simulator,
    ) -> (celox::BigUint, celox::BigUint) {
        sim.get_four_state(self.i_d)
    }
    pub fn bind<'a>(
        &'a self,
        sim: &'a mut celox::Simulator,
    ) -> synchronizer_basicBound<'a> {
        synchronizer_basicBound {
            sim,
            ids: self,
        }
    }
    pub fn tick(&self, sim: &mut celox::Simulator) {
        sim.tick(self.i_clk).unwrap();
    }
}
pub struct synchronizer_basicBound<'a> {
    sim: &'a mut celox::Simulator,
    ids: &'a synchronizer_basic,
}
impl<'a> synchronizer_basicBound<'a> {
    pub fn set_o_d(&mut self, val: u8) {
        self.ids.set_o_d(self.sim, val);
    }
    pub fn get_o_d(&mut self) -> u8 {
        self.ids.get_o_d(self.sim)
    }
    pub fn set_o_d_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_o_d_4state(self.sim, val, mask);
    }
    pub fn get_o_d_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_o_d_4state(self.sim)
    }
    pub fn set_i_rst(&mut self, val: u8) {
        self.ids.set_i_rst(self.sim, val);
    }
    pub fn get_i_rst(&mut self) -> u8 {
        self.ids.get_i_rst(self.sim)
    }
    pub fn set_i_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_rst_4state(self.sim, val, mask);
    }
    pub fn get_i_rst_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_rst_4state(self.sim)
    }
    pub fn set_i_d(&mut self, val: u8) {
        self.ids.set_i_d(self.sim, val);
    }
    pub fn get_i_d(&mut self) -> u8 {
        self.ids.get_i_d(self.sim)
    }
    pub fn set_i_d_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.ids.set_i_d_4state(self.sim, val, mask);
    }
    pub fn get_i_d_4state(&mut self) -> (celox::BigUint, celox::BigUint) {
        self.ids.get_i_d_4state(self.sim)
    }
    pub fn tick(&mut self) {
        self.sim.tick(self.ids.i_clk).unwrap();
    }
    pub fn modify<F>(&mut self, f: F)
    where
        F: FnOnce(&mut synchronizer_basicIO<'_, '_>),
    {
        self.sim
            .modify(|io| {
                let mut a_io = synchronizer_basicIO {
                    io,
                    ids: self.ids,
                };
                f(&mut a_io);
            })
            .unwrap();
    }
}
pub struct synchronizer_basicIO<'a, 'b> {
    io: &'a mut celox::IOContext<'b>,
    ids: &'a synchronizer_basic,
}
impl<'a, 'b> synchronizer_basicIO<'a, 'b> {
    pub fn set_o_d(&mut self, val: u8) {
        self.io.set(self.ids.o_d, val);
    }
    pub fn set_o_d_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.o_d, val, mask);
    }
    pub fn set_i_rst(&mut self, val: u8) {
        self.io.set(self.ids.i_rst, val);
    }
    pub fn set_i_rst_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_rst, val, mask);
    }
    pub fn set_i_d(&mut self, val: u8) {
        self.io.set(self.ids.i_d, val);
    }
    pub fn set_i_d_4state(&mut self, val: celox::BigUint, mask: celox::BigUint) {
        self.io.set_four_state(self.ids.i_d, val, mask);
    }
}
