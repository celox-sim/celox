---
source: crates/celox/tests/flip_flop.rs
expression: output
---
=== Evaluation Flip-Flops (eval_apply_ffs) ===
Trigger Group: clk (AbsoluteAddr(inst0, var0))
  Execution Unit 0:
    Entry Block: 0
    Registers:
      r0: logic<1>
      r1: bit<1>
      r2: bit<32>
      r3: bit<8>
      r4: logic<8>
      r5: bit<32>
      r6: bit<8>
      r7: logic<8>
      r8: bit<32>
      r9: bit<8>
      r10: logic<8>
      r11: bit<32>
      r12: bit<8>
      r13: logic<8>
    b0:
      r0 = Load(addr=rst (region=0), offset=0, bits=1)
      r1 = LogicNot r0
      Branch(r1 ? b1 : b2)
    b1:
      r2 = SIRValue(0x0)
      r3 = SIRValue(0xff)
      r4 = r2 And r3
      Store(addr=a (region=0), offset=0, bits=8, src_reg = 4)
      r5 = SIRValue(0x0)
      r6 = SIRValue(0xff)
      r7 = r5 And r6
      Store(addr=b (region=0), offset=0, bits=8, src_reg = 7)
      Jump(b3)
    b2:
      r8 = SIRValue(0x1)
      r9 = SIRValue(0xff)
      r10 = r8 And r9
      Store(addr=a (region=0), offset=0, bits=8, src_reg = 10)
      r11 = SIRValue(0x2)
      r12 = SIRValue(0xff)
      r13 = r11 And r12
      Store(addr=b (region=0), offset=0, bits=8, src_reg = 13)
      Jump(b3)
    b3:
      Return
Trigger Group: rst (AbsoluteAddr(inst0, var1))
  Execution Unit 0:
    Entry Block: 0
    Registers:
      r0: logic<1>
      r1: bit<1>
      r2: bit<32>
      r3: bit<8>
      r4: logic<8>
      r5: bit<32>
      r6: bit<8>
      r7: logic<8>
      r8: bit<32>
      r9: bit<8>
      r10: logic<8>
      r11: bit<32>
      r12: bit<8>
      r13: logic<8>
    b0:
      r0 = Load(addr=rst (region=0), offset=0, bits=1)
      r1 = LogicNot r0
      Branch(r1 ? b1 : b2)
    b1:
      r2 = SIRValue(0x0)
      r3 = SIRValue(0xff)
      r4 = r2 And r3
      Store(addr=a (region=0), offset=0, bits=8, src_reg = 4)
      r5 = SIRValue(0x0)
      r6 = SIRValue(0xff)
      r7 = r5 And r6
      Store(addr=b (region=0), offset=0, bits=8, src_reg = 7)
      Jump(b3)
    b2:
      r8 = SIRValue(0x1)
      r9 = SIRValue(0xff)
      r10 = r8 And r9
      Store(addr=a (region=0), offset=0, bits=8, src_reg = 10)
      r11 = SIRValue(0x2)
      r12 = SIRValue(0xff)
      r13 = r11 And r12
      Store(addr=b (region=0), offset=0, bits=8, src_reg = 13)
      Jump(b3)
    b3:
      Return

=== Evaluation Flip-Flops (eval_only_ffs) ===
Trigger Group: clk (AbsoluteAddr(inst0, var0))
  Execution Unit 0:
    Entry Block: 0
    Registers:
      r0: logic<1>
      r1: bit<1>
      r2: bit<32>
      r3: bit<8>
      r4: logic<8>
      r5: bit<32>
      r6: bit<8>
      r7: logic<8>
      r8: bit<32>
      r9: bit<8>
      r10: logic<8>
      r11: bit<32>
      r12: bit<8>
      r13: logic<8>
    b0:
      Commit(src=a (region=0), dst=a (region=1), offset=0, bits=8)
      Commit(src=b (region=0), dst=b (region=1), offset=0, bits=8)
      r0 = Load(addr=rst (region=0), offset=0, bits=1)
      r1 = LogicNot r0
      Branch(r1 ? b1 : b2)
    b1:
      r2 = SIRValue(0x0)
      r3 = SIRValue(0xff)
      r4 = r2 And r3
      Store(addr=a (region=1), offset=0, bits=8, src_reg = 4)
      r5 = SIRValue(0x0)
      r6 = SIRValue(0xff)
      r7 = r5 And r6
      Store(addr=b (region=1), offset=0, bits=8, src_reg = 7)
      Jump(b3)
    b2:
      r8 = SIRValue(0x1)
      r9 = SIRValue(0xff)
      r10 = r8 And r9
      Store(addr=a (region=1), offset=0, bits=8, src_reg = 10)
      r11 = SIRValue(0x2)
      r12 = SIRValue(0xff)
      r13 = r11 And r12
      Store(addr=b (region=1), offset=0, bits=8, src_reg = 13)
      Jump(b3)
    b3:
      Return
Trigger Group: rst (AbsoluteAddr(inst0, var1))
  Execution Unit 0:
    Entry Block: 0
    Registers:
      r0: logic<1>
      r1: bit<1>
      r2: bit<32>
      r3: bit<8>
      r4: logic<8>
      r5: bit<32>
      r6: bit<8>
      r7: logic<8>
      r8: bit<32>
      r9: bit<8>
      r10: logic<8>
      r11: bit<32>
      r12: bit<8>
      r13: logic<8>
    b0:
      Commit(src=a (region=0), dst=a (region=1), offset=0, bits=8)
      Commit(src=b (region=0), dst=b (region=1), offset=0, bits=8)
      r0 = Load(addr=rst (region=0), offset=0, bits=1)
      r1 = LogicNot r0
      Branch(r1 ? b1 : b2)
    b1:
      r2 = SIRValue(0x0)
      r3 = SIRValue(0xff)
      r4 = r2 And r3
      Store(addr=a (region=1), offset=0, bits=8, src_reg = 4)
      r5 = SIRValue(0x0)
      r6 = SIRValue(0xff)
      r7 = r5 And r6
      Store(addr=b (region=1), offset=0, bits=8, src_reg = 7)
      Jump(b3)
    b2:
      r8 = SIRValue(0x1)
      r9 = SIRValue(0xff)
      r10 = r8 And r9
      Store(addr=a (region=1), offset=0, bits=8, src_reg = 10)
      r11 = SIRValue(0x2)
      r12 = SIRValue(0xff)
      r13 = r11 And r12
      Store(addr=b (region=1), offset=0, bits=8, src_reg = 13)
      Jump(b3)
    b3:
      Return

=== Application Flip-Flops (apply_ffs) ===
Trigger Group: clk (AbsoluteAddr(inst0, var0))
  Execution Unit 0:
    Entry Block: 0
    Registers:
    b0:
      Commit(src=a (region=1), dst=a (region=0), offset=0, bits=8)
      Commit(src=b (region=1), dst=b (region=0), offset=0, bits=8)
      Return
Trigger Group: rst (AbsoluteAddr(inst0, var1))
  Execution Unit 0:
    Entry Block: 0
    Registers:
    b0:
      Commit(src=a (region=1), dst=a (region=0), offset=0, bits=8)
      Commit(src=b (region=1), dst=b (region=0), offset=0, bits=8)
      Return

=== Evaluation Combinational Logic (eval_comb) ===
Execution Unit 0:
  Entry Block: 0
  Registers:
  b0:
    Return
