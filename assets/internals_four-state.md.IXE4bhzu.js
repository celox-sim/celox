import{_ as a,o as e,c as o,ah as r}from"./chunks/framework.ojwJKwrc.js";const m=JSON.parse('{"title":"4-State Simulation","description":"","frontmatter":{},"headers":[],"relativePath":"internals/four-state.md","filePath":"internals/four-state.md"}'),d={name:"internals/four-state.md"};function i(n,t,s,l,h,c){return e(),o("div",null,[...t[0]||(t[0]=[r('<h1 id="_4-state-simulation" tabindex="-1">4-State Simulation <a class="header-anchor" href="#_4-state-simulation" aria-label="Permalink to &quot;4-State Simulation&quot;">​</a></h1><p>Celox supports IEEE 1800-compliant 4-state simulation with X (unknown) propagation.</p><h2 id="representation-model" tabindex="-1">Representation Model <a class="header-anchor" href="#representation-model" aria-label="Permalink to &quot;Representation Model&quot;">​</a></h2><p>4-state values are represented as <strong>value/mask pairs</strong>. For each bit:</p><table tabindex="0"><thead><tr><th>mask</th><th>value</th><th>Meaning</th></tr></thead><tbody><tr><td>0</td><td>0</td><td><code>0</code></td></tr><tr><td>0</td><td>1</td><td><code>1</code></td></tr><tr><td>1</td><td>0</td><td><code>X</code></td></tr><tr><td>1</td><td>1</td><td>Reserved (eliminated by normalization)</td></tr></tbody></table><p>Signals wider than 64 bits are split into chunks (<code>i64 x N</code>) and stored as a pair of value chunk arrays and mask chunk arrays (<code>TransValue::FourState { values, masks }</code>).</p><h2 id="normalization-invariant" tabindex="-1">Normalization Invariant <a class="header-anchor" href="#normalization-invariant" aria-label="Permalink to &quot;Normalization Invariant&quot;">​</a></h2><p><strong>IEEE 1800 normalization: <code>v &amp;= ~m</code></strong></p><p>At bit positions where the mask is 1, the corresponding value bit is always kept at 0. This eliminates the invalid state <code>(mask=1, value=1)</code> and guarantees consistency for comparisons and debug output.</p><h3 id="application-points" tabindex="-1">Application Points <a class="header-anchor" href="#application-points" aria-label="Permalink to &quot;Application Points&quot;">​</a></h3><p>Normalization is applied in <strong>all computation paths that produce a <code>TransValue::FourState</code></strong>.</p><table tabindex="0"><thead><tr><th>Location (arith.rs)</th><th>Operation</th><th>Width</th></tr></thead><tbody><tr><td>Assign (single chunk)</td><td>Assignment/type conversion</td><td>≤ 64bit</td></tr><tr><td>Assign (multi-chunk)</td><td>Assignment/type conversion</td><td>&gt; 64bit</td></tr><tr><td>Binary ops (single)</td><td>Arithmetic/logic/comparison/shift</td><td>≤ 64bit</td></tr><tr><td>Binary ops (multi)</td><td>Same as above</td><td>&gt; 64bit</td></tr><tr><td>Unary ops (single)</td><td>Bitwise inversion/negation/reduction</td><td>≤ 64bit</td></tr><tr><td>Unary ops (multi)</td><td>Same as above</td><td>&gt; 64bit</td></tr><tr><td>Concat (single)</td><td>Concatenation</td><td>≤ 64bit</td></tr><tr><td>Concat (multi)</td><td>Concatenation</td><td>&gt; 64bit</td></tr></tbody></table><h3 id="why-normalization-is-not-needed-on-memory-load" tabindex="-1">Why Normalization Is Not Needed on Memory Load <a class="header-anchor" href="#why-normalization-is-not-needed-on-memory-load" aria-label="Permalink to &quot;Why Normalization Is Not Needed on Memory Load&quot;">​</a></h3><p>The Load operation in <code>memory.rs</code> does not perform normalization. Values written to memory are always one of the following, both of which are already normalized:</p><ol><li>Results from operations in arith.rs (normalized as described above)</li><li>Input values via the external API (<code>set_four_state</code>)</li></ol><p>Therefore, the invariant that <strong>values in memory are always normalized</strong> holds, and re-normalization on Load is unnecessary.</p><h2 id="x-propagation-rules" tabindex="-1">X Propagation Rules <a class="header-anchor" href="#x-propagation-rules" aria-label="Permalink to &quot;X Propagation Rules&quot;">​</a></h2><p>X (mask) propagation in each operation follows IEEE 1800 semantics.</p><h3 id="bitwise-operations" tabindex="-1">Bitwise Operations <a class="header-anchor" href="#bitwise-operations" aria-label="Permalink to &quot;Bitwise Operations&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Operation</th><th>Mask computation</th><th>Notes</th></tr></thead><tbody><tr><td><code>a &amp; b</code></td><td><code>(ma | mb) &amp; ~(~va &amp; ~ma) &amp; ~(~vb &amp; ~mb)</code></td><td>A known 0 cancels X</td></tr><tr><td><code>a | b</code></td><td><code>(ma | mb) &amp; ~(va &amp; ~ma) &amp; ~(vb &amp; ~mb)</code></td><td>A known 1 cancels X</td></tr><tr><td><code>a ^ b</code></td><td><code>ma | mb</code></td><td>X if either operand is X</td></tr></tbody></table><h3 id="shift-operations" tabindex="-1">Shift Operations <a class="header-anchor" href="#shift-operations" aria-label="Permalink to &quot;Shift Operations&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Condition</th><th>Mask computation</th></tr></thead><tbody><tr><td>Shift amount is known</td><td>Shift the mask by the shift amount</td></tr><tr><td>Shift amount contains X</td><td>Entire result becomes all-X</td></tr></tbody></table><h3 id="arithmetic-and-comparison-operations" tabindex="-1">Arithmetic and Comparison Operations <a class="header-anchor" href="#arithmetic-and-comparison-operations" aria-label="Permalink to &quot;Arithmetic and Comparison Operations&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Operation</th><th>Mask computation</th><th>Notes</th></tr></thead><tbody><tr><td><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></td><td>If either operand contains X, the entire result becomes all-X</td><td>Conservative propagation</td></tr><tr><td><code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code> etc.</td><td>Same as above (1-bit result)</td><td></td></tr></tbody></table><h3 id="mux-ternary-operator" tabindex="-1">Mux (Ternary Operator) <a class="header-anchor" href="#mux-ternary-operator" aria-label="Permalink to &quot;Mux (Ternary Operator)&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Condition</th><th>Behavior</th></tr></thead><tbody><tr><td>Selector is known</td><td>Use value/mask of the selected branch</td></tr><tr><td>Selector contains X</td><td>Conservative mask: OR of both branches&#39; masks</td></tr></tbody></table><h3 id="reduction-operations" tabindex="-1">Reduction Operations <a class="header-anchor" href="#reduction-operations" aria-label="Permalink to &quot;Reduction Operations&quot;">​</a></h3><table tabindex="0"><thead><tr><th>Operation</th><th>Mask computation</th></tr></thead><tbody><tr><td><code>&amp;</code> (reduction AND)</td><td>If a known 0 exists, the result is a known 0; otherwise X</td></tr><tr><td><code>|</code> (reduction OR)</td><td>If a known 1 exists, the result is a known 1; otherwise X</td></tr><tr><td><code>^</code> (reduction XOR)</td><td>If any bit is X, the result is X</td></tr></tbody></table><h2 id="boundary-with-2-state-variables" tabindex="-1">Boundary with 2-State Variables <a class="header-anchor" href="#boundary-with-2-state-variables" aria-label="Permalink to &quot;Boundary with 2-State Variables&quot;">​</a></h2><p>When storing to a <code>bit</code>-type (2-state) variable, the mask is forcibly reset to 0 (post-store processing in <code>memory.rs</code>). This prevents unintended propagation of X through 2-state variables.</p><h2 id="test-coverage" tabindex="-1">Test Coverage <a class="header-anchor" href="#test-coverage" aria-label="Permalink to &quot;Test Coverage&quot;">​</a></h2><p>4-state related tests are located in <code>tests/four_state.rs</code>. For detailed coverage status and plans for additional tests, see <a href="./../four_state_test_plan.html">four_state_test_plan.md</a>.</p>',32)])])}const u=a(d,[["render",i]]);export{m as __pageData,u as default};
