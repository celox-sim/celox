import{_ as a,o as n,c as s,ae as i}from"./chunks/framework.Dk94_bKO.js";const u=JSON.parse('{"title":"Cascade Clocks and Race Condition Handling","description":"","frontmatter":{},"headers":[],"relativePath":"internals/cascade-limitations.md","filePath":"internals/cascade-limitations.md"}'),t={name:"internals/cascade-limitations.md"};function o(c,e,l,r,d,p){return n(),s("div",null,[...e[0]||(e[0]=[i(`<h1 id="cascade-clocks-and-race-condition-handling" tabindex="-1">Cascade Clocks and Race Condition Handling <a class="header-anchor" href="#cascade-clocks-and-race-condition-handling" aria-label="Permalink to &quot;Cascade Clocks and Race Condition Handling&quot;">​</a></h1><p>This document explains the resolution strategies and implementation details for cascade clocks (chained clocks) and the race conditions they can cause in Celox.</p><h2 id="_1-consistency-guarantees-for-cascade-clocks" tabindex="-1">1. Consistency Guarantees for Cascade Clocks <a class="header-anchor" href="#_1-consistency-guarantees-for-cascade-clocks" aria-label="Permalink to &quot;1. Consistency Guarantees for Cascade Clocks&quot;">​</a></h2><p>The current implementation uses multi-phase evaluation to guarantee logical consistency when multiple clocks (and trigger signals) change at the same simulation time.</p><h3 id="consistency-in-combinational-cascades" tabindex="-1">Consistency in Combinational Cascades <a class="header-anchor" href="#consistency-in-combinational-cascades" aria-label="Permalink to &quot;Consistency in Combinational Cascades&quot;">​</a></h3><p>Even when a change in clock <code>clk</code> drives another clock <code>gclk</code> through a combinational circuit (<code>assign</code>), the FF update timing is properly controlled.</p><div class="language-veryl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>assign gclk = clk;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>always_ff (clk) {</span></span>
<span class="line"><span>    cnt1 = cnt1 + 1;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>always_ff (gclk) {</span></span>
<span class="line"><span>    cnt2 = cnt2 + cnt1; // Must correctly reference the &quot;pre-update&quot; value of cnt1</span></span>
<span class="line"><span>}</span></span></code></pre></div><ul><li><strong>Behavior</strong>: <ol><li><strong>Phase 1 (Discovery)</strong>: Detect the edges of <code>clk</code> and <code>gclk</code>. Execute each FF block in <code>eval_only</code> (computation phase) and hold the results in a temporary area (Working Region). At this point, the computation of <code>cnt2</code> uses the value of <code>cnt1</code> from the not-yet-updated Stable region.</li><li><strong>Phase 2 (Apply)</strong>: After all triggered domains have been evaluated, commit the results to the Stable region all at once.</li><li><strong>Phase 3 (Stabilize)</strong>: Re-evaluate combinational circuits based on the updated values.</li></ol></li></ul><p>This guarantees &quot;non-blocking assignment&quot; behavior consistent with physical RTL semantics.</p><h3 id="sequential-cascades-e-g-clock-division" tabindex="-1">Sequential Cascades (e.g., Clock Division) <a class="header-anchor" href="#sequential-cascades-e-g-clock-division" aria-label="Permalink to &quot;Sequential Cascades (e.g., Clock Division)&quot;">​</a></h3><p>When an FF output serves as a trigger for another FF (e.g., a clock divider), the trigger discovery loop handles this correctly.</p><div class="language-veryl vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">veryl</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>always_ff (clk) {</span></span>
<span class="line"><span>    clk_div = ~clk_div;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>always_ff (clk_div) {</span></span>
<span class="line"><span>    cnt = cnt + 1;</span></span>
<span class="line"><span>}</span></span></code></pre></div><ul><li><strong>Behavior</strong>: <ul><li>When the evaluation of <code>clk</code> causes <code>clk_div</code> to change, the &quot;trigger discovery loop&quot; within the main loop detects this and adds the <code>clk_div</code> domain to the execution list within the same simulation step.</li><li>Thanks to multi-phase evaluation, even though the change in <code>clk_div</code> is visible, the update of <code>cnt</code> is synchronized with the updates of other signals driven by <code>clk</code>.</li></ul></li></ul><h2 id="_2-verified-tests" tabindex="-1">2. Verified Tests <a class="header-anchor" href="#_2-verified-tests" aria-label="Permalink to &quot;2. Verified Tests&quot;">​</a></h2><p>These behaviors are verified in <code>tests/cascade_race.rs</code>, where all tests are confirmed to <strong>PASS</strong>.</p><ul><li><code>test_cascade_race_condition</code>: Verifies prevention of premature value capture in combinational cascades.</li><li><code>test_sequential_cascade_race_condition</code>: Verifies correctness of trigger propagation in sequential cascades (divided clocks).</li></ul><h2 id="_3-implementation-details" tabindex="-1">3. Implementation Details <a class="header-anchor" href="#_3-implementation-details" aria-label="Permalink to &quot;3. Implementation Details&quot;">​</a></h2><ol><li><strong>Working Region (2-Region Memory)</strong>: A Working region was introduced to temporarily hold computation results instead of applying them immediately.</li><li><strong>Split Blocks (eval_only / apply)</strong>: The JIT compiler generates FF blocks split into two execution units: &quot;compute&quot; and &quot;update.&quot;</li><li><strong>Trigger Discovery Loop</strong>: Within a simulation step, evaluation and combinational propagation repeat until no signal change triggers a new domain.</li></ol><h2 id="_4-current-limitations" tabindex="-1">4. Current Limitations <a class="header-anchor" href="#_4-current-limitations" aria-label="Permalink to &quot;4. Current Limitations&quot;">​</a></h2><ul><li><strong>Circular Dependencies (Zero-delay Loop)</strong>: If a combinational loop exists between clocks, it is statically detected and rejected as a <code>CombinationalLoop</code> error at simulator build time (<code>Simulator::builder().build()</code>).</li><li><strong>Single-phase Optimization</strong>: When only a single trigger fires in a simulation step and it is not a cascade target, the eval_only/apply split is skipped and <code>eval_apply_ff_at</code> is used for batch execution as an optimization. This decision is made on a per-step basis, not based on the overall design properties.</li></ul>`,20)])])}const g=a(t,[["render",o]]);export{u as __pageData,g as default};
