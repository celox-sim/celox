import{_ as o,o as t,c as i,ah as n}from"./chunks/framework.ojwJKwrc.js";const h=JSON.parse('{"title":"Simulator Architecture","description":"","frontmatter":{},"headers":[],"relativePath":"internals/architecture.md","filePath":"internals/architecture.md"}'),a={name:"internals/architecture.md"};function l(r,e,s,c,d,u){return t(),i("div",null,[...e[0]||(e[0]=[n('<h1 id="simulator-architecture" tabindex="-1">Simulator Architecture <a class="header-anchor" href="#simulator-architecture" aria-label="Permalink to &quot;Simulator Architecture&quot;">​</a></h1><p>Celox is an engine that generates JIT-compiled native code from Veryl RTL and executes cycle-based simulation.</p><h2 id="design-philosophy-and-target" tabindex="-1">Design Philosophy and Target <a class="header-anchor" href="#design-philosophy-and-target" aria-label="Permalink to &quot;Design Philosophy and Target&quot;">​</a></h2><p>This simulator is designed with the goal of <strong>maximizing verification efficiency for modern synchronous circuit designs (RTL)</strong>.</p><ul><li><strong>RTL-focused</strong>: Physical timing reproduction that trades off against simulation speed -- such as gate-level delays (# delays) and detailed delta-cycle behavior -- is intentionally simplified by restricting the design scope to RTL-level logic verification.</li><li><strong>Performance-first</strong>: Rather than interpreter-style emulation, the simulator JIT-compiles from SIR (Simulator IR) to achieve execution throughput close to native code.</li><li><strong>Consistency as a design goal</strong>: Mechanisms such as &quot;multi-phase evaluation&quot; and &quot;cascade clock detection&quot; have been designed and implemented to guarantee consistency for challenges encountered in real RTL designs, such as multi-clock domains and zero-delay clock trees. However, there are currently <a href="./cascade-limitations.html">race condition limitations under certain conditions</a>.</li></ul><h2 id="compilation-pipeline" tabindex="-1">Compilation Pipeline <a class="header-anchor" href="#compilation-pipeline" aria-label="Permalink to &quot;Compilation Pipeline&quot;">​</a></h2><p>The transformation from Veryl source code to execution consists of the following three major phases.</p><ol><li><p><strong>Frontend (Parser/Analyzer)</strong>:</p><ul><li>Parses Veryl source and generates the analyzer IR.</li><li><code>parser::parse_ir</code> takes this as input and converts each module into a <code>SimModule</code> (a struct containing SLT (logic expressions) and SIR (instruction sequences)).</li></ul></li><li><p><strong>Middle-end (Flattening/Scheduling)</strong>:</p><ul><li><strong>Flattening</strong>: Flattens the instance hierarchy and converts module-local <code>VarId</code>s into global <code>AbsoluteAddr</code>s. Port connections are converted into <code>LogicPath</code>s.</li><li><strong>Atomization</strong>: Splits <code>LogicPath</code>s at bit boundaries (atoms) to analyze dependencies at bit-level precision.</li><li><strong>Scheduling</strong>: Topologically sorts the split atoms to determine the execution order of combinational logic.</li></ul></li><li><p><strong>Backend (JIT Compilation)</strong>:</p><ul><li><strong>Memory Layout</strong>: Determines memory offsets for all variables and places them on a single memory buffer.</li><li><strong>JIT Engine</strong>: Uses <a href="https://cranelift.dev/" target="_blank" rel="noreferrer">Cranelift</a> to compile SIR into native machine code.</li><li><strong>Runtime</strong>: Manages compiled function pointers as <code>EventRef</code>s and executes the simulation.</li></ul></li></ol><h2 id="memory-model" tabindex="-1">Memory Model <a class="header-anchor" href="#memory-model" aria-label="Permalink to &quot;Memory Model&quot;">​</a></h2><p>The simulator employs a <strong>two-region model on a single memory buffer</strong>.</p><ul><li><strong>Stable region</strong>: Holds the current committed values. Combinational logic inputs and outputs reference this region.</li><li><strong>Working region</strong>: Temporarily holds the next state of flip-flops.</li><li><strong>SignalRef</strong>: A handle that caches offsets and metadata, enabling direct memory access without going through a <code>HashMap</code>.</li></ul><h2 id="execution-control-logic" tabindex="-1">Execution Control Logic <a class="header-anchor" href="#execution-control-logic" aria-label="Permalink to &quot;Execution Control Logic&quot;">​</a></h2><p><code>Simulation::step</code> advances the simulation time by one step using the following flow.</p><ol><li><strong>Event extraction</strong>: Retrieves all events occurring at the current time (such as clock changes) from the scheduler.</li><li><strong>Clock edge detection</strong>: <ul><li>Previous values are retained in a <code>BitSet</code> and compared with the updated values to determine <code>posedge</code> / <code>negedge</code>.</li><li>Based on <code>DomainKind</code>, checks whether the target flip-flop groups have been triggered.</li></ul></li><li><strong>Silent edge skipping</strong>: When a signal value has changed but the flip-flop trigger condition is not met (e.g., a falling edge when a rising edge is specified), unnecessary flip-flop evaluation is skipped.</li><li><strong>Multi-phase evaluation</strong>: <ul><li>When multiple domains are triggered simultaneously, to maintain consistency as an event-driven model, next-state computation via <code>eval_only</code> is first performed across all domains. Then, after all computations are complete, values are written to the Stable region all at once via <code>apply</code>. This avoids value inconsistencies between simultaneously occurring events.</li></ul></li><li><strong>Cascade clock detection</strong>: <ul><li>To handle cases where a flip-flop output serves as the clock for another flip-flop (zero-delay clock tree), clock signal changes are re-scanned after domain evaluation, and evaluation is repeated until the state stabilizes.</li></ul></li></ol><h2 id="related-components" tabindex="-1">Related Components <a class="header-anchor" href="#related-components" aria-label="Permalink to &quot;Related Components&quot;">​</a></h2><ul><li><strong><code>JitBackend</code></strong>: Holds compiled function pointers (<code>SimFunc</code>) and invokes them directly through <code>EventRef</code>.</li><li><strong><code>Scheduler</code></strong>: Manages events using a <code>BinaryHeap</code> and dispatches them in chronological order.</li><li><strong><code>VcdWriter</code></strong>: Records signal changes during simulation in VCD format.</li></ul>',16)])])}const m=o(a,[["render",l]]);export{h as __pageData,m as default};
